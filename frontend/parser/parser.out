Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> empty
Rule 3     program -> program function
Rule 4     program -> program globaldeclaration
Rule 5     globaldeclaration -> type Identifier Semi
Rule 6     globaldeclaration -> type Identifier Assign expression Semi
Rule 7     type -> Int
Rule 8     function -> type Identifier LParen parameterlist RParen Semi
Rule 9     function -> type Identifier LParen parameterlist RParen LBrace block RBrace
Rule 10    parameterlist -> empty
Rule 11    parameterlist -> parameter
Rule 12    parameterlist -> parameterlist Comma parameter
Rule 13    parameter -> type Identifier
Rule 14    expressionlist -> empty
Rule 15    expressionlist -> expression
Rule 16    expressionlist -> expressionlist Comma expression
Rule 17    block -> block block_item
Rule 18    block -> empty
Rule 19    block_item -> statement
Rule 20    block_item -> declaration Semi
Rule 21    statement -> statement_matched
Rule 22    statement -> statement_unmatched
Rule 23    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 24    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 25    statement_unmatched -> If LParen expression RParen statement
Rule 26    statement_matched -> While LParen expression RParen statement_matched
Rule 27    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 28    statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched
Rule 29    statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched
Rule 30    statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched
Rule 31    statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched
Rule 32    statement_matched -> For LParen Semi expression Semi expression RParen statement_matched
Rule 33    statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched
Rule 34    statement_matched -> For LParen expression Semi Semi expression RParen statement_matched
Rule 35    statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched
Rule 36    statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched
Rule 37    statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched
Rule 38    statement_matched -> For LParen expression Semi expression Semi RParen statement_matched
Rule 39    statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched
Rule 40    statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched
Rule 41    statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched
Rule 42    statement_matched -> For LParen expression Semi Semi RParen statement_matched
Rule 43    statement_matched -> For LParen declaration Semi Semi RParen statement_matched
Rule 44    statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched
Rule 45    statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched
Rule 46    statement_matched -> For LParen Semi expression Semi RParen statement_matched
Rule 47    statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched
Rule 48    statement_matched -> For LParen Semi Semi expression RParen statement_matched
Rule 49    statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched
Rule 50    statement_matched -> For LParen Semi Semi RParen statement_matched
Rule 51    statement_unmatched -> For LParen Semi Semi RParen statement_unmatched
Rule 52    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 53    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 54    statement_matched -> Return expression Semi
Rule 55    statement_matched -> opt_expression Semi
Rule 56    statement_matched -> LBrace block RBrace
Rule 57    statement_matched -> Break Semi
Rule 58    statement_matched -> Continue Semi
Rule 59    opt_expression -> expression
Rule 60    opt_expression -> empty
Rule 61    declaration -> type Identifier
Rule 62    declaration -> type Identifier Assign expression
Rule 63    expression -> assignment
Rule 64    assignment -> conditional
Rule 65    conditional -> logical_or
Rule 66    logical_or -> logical_and
Rule 67    logical_and -> bit_or
Rule 68    bit_or -> xor
Rule 69    xor -> bit_and
Rule 70    bit_and -> equality
Rule 71    equality -> relational
Rule 72    relational -> additive
Rule 73    additive -> multiplicative
Rule 74    multiplicative -> unary
Rule 75    unary -> postfix
Rule 76    postfix -> primary
Rule 77    postfix -> Identifier LParen expressionlist RParen
Rule 78    unary -> Minus unary
Rule 79    unary -> BitNot unary
Rule 80    unary -> Not unary
Rule 81    assignment -> Identifier Assign expression
Rule 82    logical_or -> logical_or Or logical_and
Rule 83    logical_and -> logical_and And bit_or
Rule 84    bit_or -> bit_or BitOr xor
Rule 85    xor -> xor Xor bit_and
Rule 86    bit_and -> bit_and BitAnd equality
Rule 87    equality -> equality NotEqual relational
Rule 88    equality -> equality Equal relational
Rule 89    relational -> relational Less additive
Rule 90    relational -> relational Greater additive
Rule 91    relational -> relational LessEqual additive
Rule 92    relational -> relational GreaterEqual additive
Rule 93    additive -> additive Plus multiplicative
Rule 94    additive -> additive Minus multiplicative
Rule 95    multiplicative -> multiplicative Mul unary
Rule 96    multiplicative -> multiplicative Div unary
Rule 97    multiplicative -> multiplicative Mod unary
Rule 98    conditional -> logical_or Question expression Colon conditional
Rule 99    primary -> Integer
Rule 100   primary -> Identifier
Rule 101   primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 83
Assign               : 6 62 81
BitAnd               : 86
BitNot               : 79
BitOr                : 84
Break                : 57
Colon                : 98
Comma                : 12 16
Continue             : 58
Div                  : 96
Do                   : 52 53
Else                 : 23 24
Equal                : 88
For                  : 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51
Greater              : 90
GreaterEqual         : 92
Identifier           : 5 6 8 9 13 61 62 77 81 100
If                   : 23 24 25
Int                  : 7
Integer              : 99
LBrace               : 9 56
LParen               : 8 9 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 77 101
Less                 : 89
LessEqual            : 91
Minus                : 78 94
Mod                  : 97
Mul                  : 95
Not                  : 80
NotEqual             : 87
Or                   : 82
Plus                 : 93
Question             : 98
RBrace               : 9 56
RParen               : 8 9 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 77 101
Return               : 54
Semi                 : 5 6 8 20 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 53 54 55 57 58
While                : 26 27 52 53
Xor                  : 85
error                : 

Nonterminals, with rules where they appear

additive             : 72 89 90 91 92 93 94
assignment           : 63
bit_and              : 69 85 86
bit_or               : 67 83 84
block                : 9 17 56
block_item           : 17
conditional          : 64 98
declaration          : 20 29 31 35 37 39 41 43 45
empty                : 2 10 14 18 60
equality             : 70 86 87 88
expression           : 6 15 16 23 24 25 26 27 28 28 28 29 29 30 30 30 31 31 32 32 33 33 34 34 35 36 36 37 38 38 39 40 40 41 42 44 46 47 48 49 52 53 54 59 62 81 98 101
expressionlist       : 16 77
function             : 3
globaldeclaration    : 4
logical_and          : 66 82 83
logical_or           : 65 82 98
multiplicative       : 73 93 94 95 96 97
opt_expression       : 55
parameter            : 11 12
parameterlist        : 8 9 12
postfix              : 75
primary              : 76
program              : 3 4 0
relational           : 71 87 88 89 90 91 92
statement            : 19 25
statement_matched    : 21 23 23 24 26 28 29 32 34 35 38 39 42 43 46 48 50 52
statement_unmatched  : 22 24 27 30 31 33 36 37 40 41 44 45 47 49 51 53
type                 : 5 6 8 9 13 61 62
unary                : 74 78 79 80 95 96 97
xor                  : 68 84 85

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . empty
    (3) program -> . program function
    (4) program -> . program globaldeclaration
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (3) program -> program . function
    (4) program -> program . globaldeclaration
    (8) function -> . type Identifier LParen parameterlist RParen Semi
    (9) function -> . type Identifier LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> . type Identifier Semi
    (6) globaldeclaration -> . type Identifier Assign expression Semi
    (7) type -> . Int

    Int             shift and go to state 6

    function                       shift and go to state 3
    globaldeclaration              shift and go to state 4
    type                           shift and go to state 5

state 2

    (2) program -> empty .

    Int             reduce using rule 2 (program -> empty .)
    $end            reduce using rule 2 (program -> empty .)


state 3

    (3) program -> program function .

    Int             reduce using rule 3 (program -> program function .)
    $end            reduce using rule 3 (program -> program function .)


state 4

    (4) program -> program globaldeclaration .

    Int             reduce using rule 4 (program -> program globaldeclaration .)
    $end            reduce using rule 4 (program -> program globaldeclaration .)


state 5

    (8) function -> type . Identifier LParen parameterlist RParen Semi
    (9) function -> type . Identifier LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> type . Identifier Semi
    (6) globaldeclaration -> type . Identifier Assign expression Semi

    Identifier      shift and go to state 7


state 6

    (7) type -> Int .

    Identifier      reduce using rule 7 (type -> Int .)


state 7

    (8) function -> type Identifier . LParen parameterlist RParen Semi
    (9) function -> type Identifier . LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> type Identifier . Semi
    (6) globaldeclaration -> type Identifier . Assign expression Semi

    LParen          shift and go to state 8
    Semi            shift and go to state 9
    Assign          shift and go to state 10


state 8

    (8) function -> type Identifier LParen . parameterlist RParen Semi
    (9) function -> type Identifier LParen . parameterlist RParen LBrace block RBrace
    (10) parameterlist -> . empty
    (11) parameterlist -> . parameter
    (12) parameterlist -> . parameterlist Comma parameter
    (1) empty -> .
    (13) parameter -> . type Identifier
    (7) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 6

    type                           shift and go to state 11
    parameterlist                  shift and go to state 12
    empty                          shift and go to state 13
    parameter                      shift and go to state 14

state 9

    (5) globaldeclaration -> type Identifier Semi .

    Int             reduce using rule 5 (globaldeclaration -> type Identifier Semi .)
    $end            reduce using rule 5 (globaldeclaration -> type Identifier Semi .)


state 10

    (6) globaldeclaration -> type Identifier Assign . expression Semi
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 16
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 11

    (13) parameter -> type . Identifier

    Identifier      shift and go to state 36


state 12

    (8) function -> type Identifier LParen parameterlist . RParen Semi
    (9) function -> type Identifier LParen parameterlist . RParen LBrace block RBrace
    (12) parameterlist -> parameterlist . Comma parameter

    RParen          shift and go to state 37
    Comma           shift and go to state 38


state 13

    (10) parameterlist -> empty .

    RParen          reduce using rule 10 (parameterlist -> empty .)
    Comma           reduce using rule 10 (parameterlist -> empty .)


state 14

    (11) parameterlist -> parameter .

    RParen          reduce using rule 11 (parameterlist -> parameter .)
    Comma           reduce using rule 11 (parameterlist -> parameter .)


state 15

    (81) assignment -> Identifier . Assign expression
    (77) postfix -> Identifier . LParen expressionlist RParen
    (100) primary -> Identifier .

    Assign          shift and go to state 39
    LParen          shift and go to state 40
    Mul             reduce using rule 100 (primary -> Identifier .)
    Div             reduce using rule 100 (primary -> Identifier .)
    Mod             reduce using rule 100 (primary -> Identifier .)
    Plus            reduce using rule 100 (primary -> Identifier .)
    Minus           reduce using rule 100 (primary -> Identifier .)
    Less            reduce using rule 100 (primary -> Identifier .)
    Greater         reduce using rule 100 (primary -> Identifier .)
    LessEqual       reduce using rule 100 (primary -> Identifier .)
    GreaterEqual    reduce using rule 100 (primary -> Identifier .)
    NotEqual        reduce using rule 100 (primary -> Identifier .)
    Equal           reduce using rule 100 (primary -> Identifier .)
    BitAnd          reduce using rule 100 (primary -> Identifier .)
    Xor             reduce using rule 100 (primary -> Identifier .)
    BitOr           reduce using rule 100 (primary -> Identifier .)
    And             reduce using rule 100 (primary -> Identifier .)
    Question        reduce using rule 100 (primary -> Identifier .)
    Or              reduce using rule 100 (primary -> Identifier .)
    Semi            reduce using rule 100 (primary -> Identifier .)
    RParen          reduce using rule 100 (primary -> Identifier .)
    Comma           reduce using rule 100 (primary -> Identifier .)
    Colon           reduce using rule 100 (primary -> Identifier .)


state 16

    (6) globaldeclaration -> type Identifier Assign expression . Semi

    Semi            shift and go to state 41


state 17

    (63) expression -> assignment .

    Semi            reduce using rule 63 (expression -> assignment .)
    RParen          reduce using rule 63 (expression -> assignment .)
    Comma           reduce using rule 63 (expression -> assignment .)
    Colon           reduce using rule 63 (expression -> assignment .)


state 18

    (64) assignment -> conditional .

    Semi            reduce using rule 64 (assignment -> conditional .)
    RParen          reduce using rule 64 (assignment -> conditional .)
    Comma           reduce using rule 64 (assignment -> conditional .)
    Colon           reduce using rule 64 (assignment -> conditional .)


state 19

    (65) conditional -> logical_or .
    (98) conditional -> logical_or . Question expression Colon conditional
    (82) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 65 (conditional -> logical_or .)
    RParen          reduce using rule 65 (conditional -> logical_or .)
    Comma           reduce using rule 65 (conditional -> logical_or .)
    Colon           reduce using rule 65 (conditional -> logical_or .)
    Question        shift and go to state 42
    Or              shift and go to state 43


state 20

    (66) logical_or -> logical_and .
    (83) logical_and -> logical_and . And bit_or

    Question        reduce using rule 66 (logical_or -> logical_and .)
    Or              reduce using rule 66 (logical_or -> logical_and .)
    Semi            reduce using rule 66 (logical_or -> logical_and .)
    RParen          reduce using rule 66 (logical_or -> logical_and .)
    Comma           reduce using rule 66 (logical_or -> logical_and .)
    Colon           reduce using rule 66 (logical_or -> logical_and .)
    And             shift and go to state 44


state 21

    (67) logical_and -> bit_or .
    (84) bit_or -> bit_or . BitOr xor

    And             reduce using rule 67 (logical_and -> bit_or .)
    Question        reduce using rule 67 (logical_and -> bit_or .)
    Or              reduce using rule 67 (logical_and -> bit_or .)
    Semi            reduce using rule 67 (logical_and -> bit_or .)
    RParen          reduce using rule 67 (logical_and -> bit_or .)
    Comma           reduce using rule 67 (logical_and -> bit_or .)
    Colon           reduce using rule 67 (logical_and -> bit_or .)
    BitOr           shift and go to state 45


state 22

    (68) bit_or -> xor .
    (85) xor -> xor . Xor bit_and

    BitOr           reduce using rule 68 (bit_or -> xor .)
    And             reduce using rule 68 (bit_or -> xor .)
    Question        reduce using rule 68 (bit_or -> xor .)
    Or              reduce using rule 68 (bit_or -> xor .)
    Semi            reduce using rule 68 (bit_or -> xor .)
    RParen          reduce using rule 68 (bit_or -> xor .)
    Comma           reduce using rule 68 (bit_or -> xor .)
    Colon           reduce using rule 68 (bit_or -> xor .)
    Xor             shift and go to state 46


state 23

    (69) xor -> bit_and .
    (86) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 69 (xor -> bit_and .)
    BitOr           reduce using rule 69 (xor -> bit_and .)
    And             reduce using rule 69 (xor -> bit_and .)
    Question        reduce using rule 69 (xor -> bit_and .)
    Or              reduce using rule 69 (xor -> bit_and .)
    Semi            reduce using rule 69 (xor -> bit_and .)
    RParen          reduce using rule 69 (xor -> bit_and .)
    Comma           reduce using rule 69 (xor -> bit_and .)
    Colon           reduce using rule 69 (xor -> bit_and .)
    BitAnd          shift and go to state 47


state 24

    (70) bit_and -> equality .
    (87) equality -> equality . NotEqual relational
    (88) equality -> equality . Equal relational

    BitAnd          reduce using rule 70 (bit_and -> equality .)
    Xor             reduce using rule 70 (bit_and -> equality .)
    BitOr           reduce using rule 70 (bit_and -> equality .)
    And             reduce using rule 70 (bit_and -> equality .)
    Question        reduce using rule 70 (bit_and -> equality .)
    Or              reduce using rule 70 (bit_and -> equality .)
    Semi            reduce using rule 70 (bit_and -> equality .)
    RParen          reduce using rule 70 (bit_and -> equality .)
    Comma           reduce using rule 70 (bit_and -> equality .)
    Colon           reduce using rule 70 (bit_and -> equality .)
    NotEqual        shift and go to state 48
    Equal           shift and go to state 49


state 25

    (71) equality -> relational .
    (89) relational -> relational . Less additive
    (90) relational -> relational . Greater additive
    (91) relational -> relational . LessEqual additive
    (92) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 71 (equality -> relational .)
    Equal           reduce using rule 71 (equality -> relational .)
    BitAnd          reduce using rule 71 (equality -> relational .)
    Xor             reduce using rule 71 (equality -> relational .)
    BitOr           reduce using rule 71 (equality -> relational .)
    And             reduce using rule 71 (equality -> relational .)
    Question        reduce using rule 71 (equality -> relational .)
    Or              reduce using rule 71 (equality -> relational .)
    Semi            reduce using rule 71 (equality -> relational .)
    RParen          reduce using rule 71 (equality -> relational .)
    Comma           reduce using rule 71 (equality -> relational .)
    Colon           reduce using rule 71 (equality -> relational .)
    Less            shift and go to state 50
    Greater         shift and go to state 51
    LessEqual       shift and go to state 52
    GreaterEqual    shift and go to state 53


state 26

    (72) relational -> additive .
    (93) additive -> additive . Plus multiplicative
    (94) additive -> additive . Minus multiplicative

    Less            reduce using rule 72 (relational -> additive .)
    Greater         reduce using rule 72 (relational -> additive .)
    LessEqual       reduce using rule 72 (relational -> additive .)
    GreaterEqual    reduce using rule 72 (relational -> additive .)
    NotEqual        reduce using rule 72 (relational -> additive .)
    Equal           reduce using rule 72 (relational -> additive .)
    BitAnd          reduce using rule 72 (relational -> additive .)
    Xor             reduce using rule 72 (relational -> additive .)
    BitOr           reduce using rule 72 (relational -> additive .)
    And             reduce using rule 72 (relational -> additive .)
    Question        reduce using rule 72 (relational -> additive .)
    Or              reduce using rule 72 (relational -> additive .)
    Semi            reduce using rule 72 (relational -> additive .)
    RParen          reduce using rule 72 (relational -> additive .)
    Comma           reduce using rule 72 (relational -> additive .)
    Colon           reduce using rule 72 (relational -> additive .)
    Plus            shift and go to state 54
    Minus           shift and go to state 55


state 27

    (73) additive -> multiplicative .
    (95) multiplicative -> multiplicative . Mul unary
    (96) multiplicative -> multiplicative . Div unary
    (97) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 73 (additive -> multiplicative .)
    Minus           reduce using rule 73 (additive -> multiplicative .)
    Less            reduce using rule 73 (additive -> multiplicative .)
    Greater         reduce using rule 73 (additive -> multiplicative .)
    LessEqual       reduce using rule 73 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 73 (additive -> multiplicative .)
    NotEqual        reduce using rule 73 (additive -> multiplicative .)
    Equal           reduce using rule 73 (additive -> multiplicative .)
    BitAnd          reduce using rule 73 (additive -> multiplicative .)
    Xor             reduce using rule 73 (additive -> multiplicative .)
    BitOr           reduce using rule 73 (additive -> multiplicative .)
    And             reduce using rule 73 (additive -> multiplicative .)
    Question        reduce using rule 73 (additive -> multiplicative .)
    Or              reduce using rule 73 (additive -> multiplicative .)
    Semi            reduce using rule 73 (additive -> multiplicative .)
    RParen          reduce using rule 73 (additive -> multiplicative .)
    Comma           reduce using rule 73 (additive -> multiplicative .)
    Colon           reduce using rule 73 (additive -> multiplicative .)
    Mul             shift and go to state 56
    Div             shift and go to state 57
    Mod             shift and go to state 58


state 28

    (78) unary -> Minus . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 59
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 29

    (74) multiplicative -> unary .

    Mul             reduce using rule 74 (multiplicative -> unary .)
    Div             reduce using rule 74 (multiplicative -> unary .)
    Mod             reduce using rule 74 (multiplicative -> unary .)
    Plus            reduce using rule 74 (multiplicative -> unary .)
    Minus           reduce using rule 74 (multiplicative -> unary .)
    Less            reduce using rule 74 (multiplicative -> unary .)
    Greater         reduce using rule 74 (multiplicative -> unary .)
    LessEqual       reduce using rule 74 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 74 (multiplicative -> unary .)
    NotEqual        reduce using rule 74 (multiplicative -> unary .)
    Equal           reduce using rule 74 (multiplicative -> unary .)
    BitAnd          reduce using rule 74 (multiplicative -> unary .)
    Xor             reduce using rule 74 (multiplicative -> unary .)
    BitOr           reduce using rule 74 (multiplicative -> unary .)
    And             reduce using rule 74 (multiplicative -> unary .)
    Question        reduce using rule 74 (multiplicative -> unary .)
    Or              reduce using rule 74 (multiplicative -> unary .)
    Semi            reduce using rule 74 (multiplicative -> unary .)
    RParen          reduce using rule 74 (multiplicative -> unary .)
    Comma           reduce using rule 74 (multiplicative -> unary .)
    Colon           reduce using rule 74 (multiplicative -> unary .)


state 30

    (75) unary -> postfix .

    Mul             reduce using rule 75 (unary -> postfix .)
    Div             reduce using rule 75 (unary -> postfix .)
    Mod             reduce using rule 75 (unary -> postfix .)
    Plus            reduce using rule 75 (unary -> postfix .)
    Minus           reduce using rule 75 (unary -> postfix .)
    Less            reduce using rule 75 (unary -> postfix .)
    Greater         reduce using rule 75 (unary -> postfix .)
    LessEqual       reduce using rule 75 (unary -> postfix .)
    GreaterEqual    reduce using rule 75 (unary -> postfix .)
    NotEqual        reduce using rule 75 (unary -> postfix .)
    Equal           reduce using rule 75 (unary -> postfix .)
    BitAnd          reduce using rule 75 (unary -> postfix .)
    Xor             reduce using rule 75 (unary -> postfix .)
    BitOr           reduce using rule 75 (unary -> postfix .)
    And             reduce using rule 75 (unary -> postfix .)
    Question        reduce using rule 75 (unary -> postfix .)
    Or              reduce using rule 75 (unary -> postfix .)
    Semi            reduce using rule 75 (unary -> postfix .)
    RParen          reduce using rule 75 (unary -> postfix .)
    Comma           reduce using rule 75 (unary -> postfix .)
    Colon           reduce using rule 75 (unary -> postfix .)


state 31

    (79) unary -> BitNot . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 61
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 32

    (80) unary -> Not . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 62
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 33

    (76) postfix -> primary .

    Mul             reduce using rule 76 (postfix -> primary .)
    Div             reduce using rule 76 (postfix -> primary .)
    Mod             reduce using rule 76 (postfix -> primary .)
    Plus            reduce using rule 76 (postfix -> primary .)
    Minus           reduce using rule 76 (postfix -> primary .)
    Less            reduce using rule 76 (postfix -> primary .)
    Greater         reduce using rule 76 (postfix -> primary .)
    LessEqual       reduce using rule 76 (postfix -> primary .)
    GreaterEqual    reduce using rule 76 (postfix -> primary .)
    NotEqual        reduce using rule 76 (postfix -> primary .)
    Equal           reduce using rule 76 (postfix -> primary .)
    BitAnd          reduce using rule 76 (postfix -> primary .)
    Xor             reduce using rule 76 (postfix -> primary .)
    BitOr           reduce using rule 76 (postfix -> primary .)
    And             reduce using rule 76 (postfix -> primary .)
    Question        reduce using rule 76 (postfix -> primary .)
    Or              reduce using rule 76 (postfix -> primary .)
    Semi            reduce using rule 76 (postfix -> primary .)
    RParen          reduce using rule 76 (postfix -> primary .)
    Comma           reduce using rule 76 (postfix -> primary .)
    Colon           reduce using rule 76 (postfix -> primary .)


state 34

    (101) primary -> LParen . expression RParen
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 63
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 35

    (99) primary -> Integer .

    Mul             reduce using rule 99 (primary -> Integer .)
    Div             reduce using rule 99 (primary -> Integer .)
    Mod             reduce using rule 99 (primary -> Integer .)
    Plus            reduce using rule 99 (primary -> Integer .)
    Minus           reduce using rule 99 (primary -> Integer .)
    Less            reduce using rule 99 (primary -> Integer .)
    Greater         reduce using rule 99 (primary -> Integer .)
    LessEqual       reduce using rule 99 (primary -> Integer .)
    GreaterEqual    reduce using rule 99 (primary -> Integer .)
    NotEqual        reduce using rule 99 (primary -> Integer .)
    Equal           reduce using rule 99 (primary -> Integer .)
    BitAnd          reduce using rule 99 (primary -> Integer .)
    Xor             reduce using rule 99 (primary -> Integer .)
    BitOr           reduce using rule 99 (primary -> Integer .)
    And             reduce using rule 99 (primary -> Integer .)
    Question        reduce using rule 99 (primary -> Integer .)
    Or              reduce using rule 99 (primary -> Integer .)
    Semi            reduce using rule 99 (primary -> Integer .)
    RParen          reduce using rule 99 (primary -> Integer .)
    Comma           reduce using rule 99 (primary -> Integer .)
    Colon           reduce using rule 99 (primary -> Integer .)


state 36

    (13) parameter -> type Identifier .

    RParen          reduce using rule 13 (parameter -> type Identifier .)
    Comma           reduce using rule 13 (parameter -> type Identifier .)


state 37

    (8) function -> type Identifier LParen parameterlist RParen . Semi
    (9) function -> type Identifier LParen parameterlist RParen . LBrace block RBrace

    Semi            shift and go to state 64
    LBrace          shift and go to state 65


state 38

    (12) parameterlist -> parameterlist Comma . parameter
    (13) parameter -> . type Identifier
    (7) type -> . Int

    Int             shift and go to state 6

    parameter                      shift and go to state 66
    type                           shift and go to state 11

state 39

    (81) assignment -> Identifier Assign . expression
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 67
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 40

    (77) postfix -> Identifier LParen . expressionlist RParen
    (14) expressionlist -> . empty
    (15) expressionlist -> . expression
    (16) expressionlist -> . expressionlist Comma expression
    (1) empty -> .
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expressionlist                 shift and go to state 68
    empty                          shift and go to state 69
    expression                     shift and go to state 70
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 41

    (6) globaldeclaration -> type Identifier Assign expression Semi .

    Int             reduce using rule 6 (globaldeclaration -> type Identifier Assign expression Semi .)
    $end            reduce using rule 6 (globaldeclaration -> type Identifier Assign expression Semi .)


state 42

    (98) conditional -> logical_or Question . expression Colon conditional
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    logical_or                     shift and go to state 19
    expression                     shift and go to state 71
    conditional                    shift and go to state 18
    assignment                     shift and go to state 17
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 43

    (82) logical_or -> logical_or Or . logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    logical_and                    shift and go to state 72
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 44

    (83) logical_and -> logical_and And . bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    bit_or                         shift and go to state 73
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 45

    (84) bit_or -> bit_or BitOr . xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    xor                            shift and go to state 74
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 46

    (85) xor -> xor Xor . bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    bit_and                        shift and go to state 75
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 47

    (86) bit_and -> bit_and BitAnd . equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    equality                       shift and go to state 76
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 48

    (87) equality -> equality NotEqual . relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    relational                     shift and go to state 77
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 49

    (88) equality -> equality Equal . relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    relational                     shift and go to state 78
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 50

    (89) relational -> relational Less . additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    additive                       shift and go to state 79
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 51

    (90) relational -> relational Greater . additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    additive                       shift and go to state 80
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 52

    (91) relational -> relational LessEqual . additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    additive                       shift and go to state 81
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 53

    (92) relational -> relational GreaterEqual . additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    additive                       shift and go to state 82
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 54

    (93) additive -> additive Plus . multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    multiplicative                 shift and go to state 83
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 55

    (94) additive -> additive Minus . multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    multiplicative                 shift and go to state 84
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 56

    (95) multiplicative -> multiplicative Mul . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 85
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 57

    (96) multiplicative -> multiplicative Div . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 86
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 58

    (97) multiplicative -> multiplicative Mod . unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    unary                          shift and go to state 87
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 59

    (78) unary -> Minus unary .

    Mul             reduce using rule 78 (unary -> Minus unary .)
    Div             reduce using rule 78 (unary -> Minus unary .)
    Mod             reduce using rule 78 (unary -> Minus unary .)
    Plus            reduce using rule 78 (unary -> Minus unary .)
    Minus           reduce using rule 78 (unary -> Minus unary .)
    Less            reduce using rule 78 (unary -> Minus unary .)
    Greater         reduce using rule 78 (unary -> Minus unary .)
    LessEqual       reduce using rule 78 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 78 (unary -> Minus unary .)
    NotEqual        reduce using rule 78 (unary -> Minus unary .)
    Equal           reduce using rule 78 (unary -> Minus unary .)
    BitAnd          reduce using rule 78 (unary -> Minus unary .)
    Xor             reduce using rule 78 (unary -> Minus unary .)
    BitOr           reduce using rule 78 (unary -> Minus unary .)
    And             reduce using rule 78 (unary -> Minus unary .)
    Question        reduce using rule 78 (unary -> Minus unary .)
    Or              reduce using rule 78 (unary -> Minus unary .)
    Semi            reduce using rule 78 (unary -> Minus unary .)
    RParen          reduce using rule 78 (unary -> Minus unary .)
    Comma           reduce using rule 78 (unary -> Minus unary .)
    Colon           reduce using rule 78 (unary -> Minus unary .)


state 60

    (77) postfix -> Identifier . LParen expressionlist RParen
    (100) primary -> Identifier .

    LParen          shift and go to state 40
    Mul             reduce using rule 100 (primary -> Identifier .)
    Div             reduce using rule 100 (primary -> Identifier .)
    Mod             reduce using rule 100 (primary -> Identifier .)
    Plus            reduce using rule 100 (primary -> Identifier .)
    Minus           reduce using rule 100 (primary -> Identifier .)
    Less            reduce using rule 100 (primary -> Identifier .)
    Greater         reduce using rule 100 (primary -> Identifier .)
    LessEqual       reduce using rule 100 (primary -> Identifier .)
    GreaterEqual    reduce using rule 100 (primary -> Identifier .)
    NotEqual        reduce using rule 100 (primary -> Identifier .)
    Equal           reduce using rule 100 (primary -> Identifier .)
    BitAnd          reduce using rule 100 (primary -> Identifier .)
    Xor             reduce using rule 100 (primary -> Identifier .)
    BitOr           reduce using rule 100 (primary -> Identifier .)
    And             reduce using rule 100 (primary -> Identifier .)
    Question        reduce using rule 100 (primary -> Identifier .)
    Or              reduce using rule 100 (primary -> Identifier .)
    Semi            reduce using rule 100 (primary -> Identifier .)
    RParen          reduce using rule 100 (primary -> Identifier .)
    Comma           reduce using rule 100 (primary -> Identifier .)
    Colon           reduce using rule 100 (primary -> Identifier .)


state 61

    (79) unary -> BitNot unary .

    Mul             reduce using rule 79 (unary -> BitNot unary .)
    Div             reduce using rule 79 (unary -> BitNot unary .)
    Mod             reduce using rule 79 (unary -> BitNot unary .)
    Plus            reduce using rule 79 (unary -> BitNot unary .)
    Minus           reduce using rule 79 (unary -> BitNot unary .)
    Less            reduce using rule 79 (unary -> BitNot unary .)
    Greater         reduce using rule 79 (unary -> BitNot unary .)
    LessEqual       reduce using rule 79 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 79 (unary -> BitNot unary .)
    NotEqual        reduce using rule 79 (unary -> BitNot unary .)
    Equal           reduce using rule 79 (unary -> BitNot unary .)
    BitAnd          reduce using rule 79 (unary -> BitNot unary .)
    Xor             reduce using rule 79 (unary -> BitNot unary .)
    BitOr           reduce using rule 79 (unary -> BitNot unary .)
    And             reduce using rule 79 (unary -> BitNot unary .)
    Question        reduce using rule 79 (unary -> BitNot unary .)
    Or              reduce using rule 79 (unary -> BitNot unary .)
    Semi            reduce using rule 79 (unary -> BitNot unary .)
    RParen          reduce using rule 79 (unary -> BitNot unary .)
    Comma           reduce using rule 79 (unary -> BitNot unary .)
    Colon           reduce using rule 79 (unary -> BitNot unary .)


state 62

    (80) unary -> Not unary .

    Mul             reduce using rule 80 (unary -> Not unary .)
    Div             reduce using rule 80 (unary -> Not unary .)
    Mod             reduce using rule 80 (unary -> Not unary .)
    Plus            reduce using rule 80 (unary -> Not unary .)
    Minus           reduce using rule 80 (unary -> Not unary .)
    Less            reduce using rule 80 (unary -> Not unary .)
    Greater         reduce using rule 80 (unary -> Not unary .)
    LessEqual       reduce using rule 80 (unary -> Not unary .)
    GreaterEqual    reduce using rule 80 (unary -> Not unary .)
    NotEqual        reduce using rule 80 (unary -> Not unary .)
    Equal           reduce using rule 80 (unary -> Not unary .)
    BitAnd          reduce using rule 80 (unary -> Not unary .)
    Xor             reduce using rule 80 (unary -> Not unary .)
    BitOr           reduce using rule 80 (unary -> Not unary .)
    And             reduce using rule 80 (unary -> Not unary .)
    Question        reduce using rule 80 (unary -> Not unary .)
    Or              reduce using rule 80 (unary -> Not unary .)
    Semi            reduce using rule 80 (unary -> Not unary .)
    RParen          reduce using rule 80 (unary -> Not unary .)
    Comma           reduce using rule 80 (unary -> Not unary .)
    Colon           reduce using rule 80 (unary -> Not unary .)


state 63

    (101) primary -> LParen expression . RParen

    RParen          shift and go to state 88


state 64

    (8) function -> type Identifier LParen parameterlist RParen Semi .

    Int             reduce using rule 8 (function -> type Identifier LParen parameterlist RParen Semi .)
    $end            reduce using rule 8 (function -> type Identifier LParen parameterlist RParen Semi .)


state 65

    (9) function -> type Identifier LParen parameterlist RParen LBrace . block RBrace
    (17) block -> . block block_item
    (18) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 89
    empty                          shift and go to state 90

state 66

    (12) parameterlist -> parameterlist Comma parameter .

    RParen          reduce using rule 12 (parameterlist -> parameterlist Comma parameter .)
    Comma           reduce using rule 12 (parameterlist -> parameterlist Comma parameter .)


state 67

    (81) assignment -> Identifier Assign expression .

    Semi            reduce using rule 81 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 81 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 81 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 81 (assignment -> Identifier Assign expression .)


state 68

    (77) postfix -> Identifier LParen expressionlist . RParen
    (16) expressionlist -> expressionlist . Comma expression

    RParen          shift and go to state 91
    Comma           shift and go to state 92


state 69

    (14) expressionlist -> empty .

    RParen          reduce using rule 14 (expressionlist -> empty .)
    Comma           reduce using rule 14 (expressionlist -> empty .)


state 70

    (15) expressionlist -> expression .

    RParen          reduce using rule 15 (expressionlist -> expression .)
    Comma           reduce using rule 15 (expressionlist -> expression .)


state 71

    (98) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 93


state 72

    (82) logical_or -> logical_or Or logical_and .
    (83) logical_and -> logical_and . And bit_or

    Question        reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 82 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 44


state 73

    (83) logical_and -> logical_and And bit_or .
    (84) bit_or -> bit_or . BitOr xor

    And             reduce using rule 83 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 83 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 83 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 83 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 83 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 83 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 83 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 45


state 74

    (84) bit_or -> bit_or BitOr xor .
    (85) xor -> xor . Xor bit_and

    BitOr           reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 84 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 46


state 75

    (85) xor -> xor Xor bit_and .
    (86) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 85 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 85 (xor -> xor Xor bit_and .)
    And             reduce using rule 85 (xor -> xor Xor bit_and .)
    Question        reduce using rule 85 (xor -> xor Xor bit_and .)
    Or              reduce using rule 85 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 85 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 85 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 85 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 85 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 47


state 76

    (86) bit_and -> bit_and BitAnd equality .
    (87) equality -> equality . NotEqual relational
    (88) equality -> equality . Equal relational

    BitAnd          reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 86 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 48
    Equal           shift and go to state 49


state 77

    (87) equality -> equality NotEqual relational .
    (89) relational -> relational . Less additive
    (90) relational -> relational . Greater additive
    (91) relational -> relational . LessEqual additive
    (92) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 87 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 87 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 87 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 87 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 87 (equality -> equality NotEqual relational .)
    And             reduce using rule 87 (equality -> equality NotEqual relational .)
    Question        reduce using rule 87 (equality -> equality NotEqual relational .)
    Or              reduce using rule 87 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 87 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 87 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 87 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 87 (equality -> equality NotEqual relational .)
    Less            shift and go to state 50
    Greater         shift and go to state 51
    LessEqual       shift and go to state 52
    GreaterEqual    shift and go to state 53


state 78

    (88) equality -> equality Equal relational .
    (89) relational -> relational . Less additive
    (90) relational -> relational . Greater additive
    (91) relational -> relational . LessEqual additive
    (92) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 88 (equality -> equality Equal relational .)
    Equal           reduce using rule 88 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 88 (equality -> equality Equal relational .)
    Xor             reduce using rule 88 (equality -> equality Equal relational .)
    BitOr           reduce using rule 88 (equality -> equality Equal relational .)
    And             reduce using rule 88 (equality -> equality Equal relational .)
    Question        reduce using rule 88 (equality -> equality Equal relational .)
    Or              reduce using rule 88 (equality -> equality Equal relational .)
    Semi            reduce using rule 88 (equality -> equality Equal relational .)
    RParen          reduce using rule 88 (equality -> equality Equal relational .)
    Comma           reduce using rule 88 (equality -> equality Equal relational .)
    Colon           reduce using rule 88 (equality -> equality Equal relational .)
    Less            shift and go to state 50
    Greater         shift and go to state 51
    LessEqual       shift and go to state 52
    GreaterEqual    shift and go to state 53


state 79

    (89) relational -> relational Less additive .
    (93) additive -> additive . Plus multiplicative
    (94) additive -> additive . Minus multiplicative

    Less            reduce using rule 89 (relational -> relational Less additive .)
    Greater         reduce using rule 89 (relational -> relational Less additive .)
    LessEqual       reduce using rule 89 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 89 (relational -> relational Less additive .)
    NotEqual        reduce using rule 89 (relational -> relational Less additive .)
    Equal           reduce using rule 89 (relational -> relational Less additive .)
    BitAnd          reduce using rule 89 (relational -> relational Less additive .)
    Xor             reduce using rule 89 (relational -> relational Less additive .)
    BitOr           reduce using rule 89 (relational -> relational Less additive .)
    And             reduce using rule 89 (relational -> relational Less additive .)
    Question        reduce using rule 89 (relational -> relational Less additive .)
    Or              reduce using rule 89 (relational -> relational Less additive .)
    Semi            reduce using rule 89 (relational -> relational Less additive .)
    RParen          reduce using rule 89 (relational -> relational Less additive .)
    Comma           reduce using rule 89 (relational -> relational Less additive .)
    Colon           reduce using rule 89 (relational -> relational Less additive .)
    Plus            shift and go to state 54
    Minus           shift and go to state 55


state 80

    (90) relational -> relational Greater additive .
    (93) additive -> additive . Plus multiplicative
    (94) additive -> additive . Minus multiplicative

    Less            reduce using rule 90 (relational -> relational Greater additive .)
    Greater         reduce using rule 90 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 90 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 90 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 90 (relational -> relational Greater additive .)
    Equal           reduce using rule 90 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 90 (relational -> relational Greater additive .)
    Xor             reduce using rule 90 (relational -> relational Greater additive .)
    BitOr           reduce using rule 90 (relational -> relational Greater additive .)
    And             reduce using rule 90 (relational -> relational Greater additive .)
    Question        reduce using rule 90 (relational -> relational Greater additive .)
    Or              reduce using rule 90 (relational -> relational Greater additive .)
    Semi            reduce using rule 90 (relational -> relational Greater additive .)
    RParen          reduce using rule 90 (relational -> relational Greater additive .)
    Comma           reduce using rule 90 (relational -> relational Greater additive .)
    Colon           reduce using rule 90 (relational -> relational Greater additive .)
    Plus            shift and go to state 54
    Minus           shift and go to state 55


state 81

    (91) relational -> relational LessEqual additive .
    (93) additive -> additive . Plus multiplicative
    (94) additive -> additive . Minus multiplicative

    Less            reduce using rule 91 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 91 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 91 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 91 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 91 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 91 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 91 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 91 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 91 (relational -> relational LessEqual additive .)
    And             reduce using rule 91 (relational -> relational LessEqual additive .)
    Question        reduce using rule 91 (relational -> relational LessEqual additive .)
    Or              reduce using rule 91 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 91 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 91 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 91 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 91 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 54
    Minus           shift and go to state 55


state 82

    (92) relational -> relational GreaterEqual additive .
    (93) additive -> additive . Plus multiplicative
    (94) additive -> additive . Minus multiplicative

    Less            reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 92 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 92 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 92 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 92 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 92 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 92 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 92 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 92 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 54
    Minus           shift and go to state 55


state 83

    (93) additive -> additive Plus multiplicative .
    (95) multiplicative -> multiplicative . Mul unary
    (96) multiplicative -> multiplicative . Div unary
    (97) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 93 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 93 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 93 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 93 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 93 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 93 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 93 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 93 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 93 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 93 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 93 (additive -> additive Plus multiplicative .)
    And             reduce using rule 93 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 93 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 93 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 93 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 93 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 93 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 93 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 56
    Div             shift and go to state 57
    Mod             shift and go to state 58


state 84

    (94) additive -> additive Minus multiplicative .
    (95) multiplicative -> multiplicative . Mul unary
    (96) multiplicative -> multiplicative . Div unary
    (97) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 94 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 94 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 94 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 94 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 94 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 94 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 94 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 94 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 94 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 94 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 94 (additive -> additive Minus multiplicative .)
    And             reduce using rule 94 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 94 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 94 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 94 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 94 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 94 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 94 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 56
    Div             shift and go to state 57
    Mod             shift and go to state 58


state 85

    (95) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 95 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 95 (multiplicative -> multiplicative Mul unary .)


state 86

    (96) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 96 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 96 (multiplicative -> multiplicative Div unary .)


state 87

    (97) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 97 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 97 (multiplicative -> multiplicative Mod unary .)


state 88

    (101) primary -> LParen expression RParen .

    Mul             reduce using rule 101 (primary -> LParen expression RParen .)
    Div             reduce using rule 101 (primary -> LParen expression RParen .)
    Mod             reduce using rule 101 (primary -> LParen expression RParen .)
    Plus            reduce using rule 101 (primary -> LParen expression RParen .)
    Minus           reduce using rule 101 (primary -> LParen expression RParen .)
    Less            reduce using rule 101 (primary -> LParen expression RParen .)
    Greater         reduce using rule 101 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 101 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 101 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 101 (primary -> LParen expression RParen .)
    Equal           reduce using rule 101 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 101 (primary -> LParen expression RParen .)
    Xor             reduce using rule 101 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 101 (primary -> LParen expression RParen .)
    And             reduce using rule 101 (primary -> LParen expression RParen .)
    Question        reduce using rule 101 (primary -> LParen expression RParen .)
    Or              reduce using rule 101 (primary -> LParen expression RParen .)
    Semi            reduce using rule 101 (primary -> LParen expression RParen .)
    RParen          reduce using rule 101 (primary -> LParen expression RParen .)
    Comma           reduce using rule 101 (primary -> LParen expression RParen .)
    Colon           reduce using rule 101 (primary -> LParen expression RParen .)


state 89

    (9) function -> type Identifier LParen parameterlist RParen LBrace block . RBrace
    (17) block -> block . block_item
    (19) block_item -> . statement
    (20) block_item -> . declaration Semi
    (21) statement -> . statement_matched
    (22) statement -> . statement_unmatched
    (61) declaration -> . type Identifier
    (62) declaration -> . type Identifier Assign expression
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (7) type -> . Int
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RBrace          shift and go to state 96
    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    type                           shift and go to state 94
    block_item                     shift and go to state 97
    statement                      shift and go to state 98
    declaration                    shift and go to state 99
    statement_matched              shift and go to state 100
    statement_unmatched            shift and go to state 101
    expression                     shift and go to state 102
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 90

    (18) block -> empty .

    RBrace          reduce using rule 18 (block -> empty .)
    If              reduce using rule 18 (block -> empty .)
    While           reduce using rule 18 (block -> empty .)
    For             reduce using rule 18 (block -> empty .)
    Do              reduce using rule 18 (block -> empty .)
    Return          reduce using rule 18 (block -> empty .)
    LBrace          reduce using rule 18 (block -> empty .)
    Break           reduce using rule 18 (block -> empty .)
    Continue        reduce using rule 18 (block -> empty .)
    Int             reduce using rule 18 (block -> empty .)
    Identifier      reduce using rule 18 (block -> empty .)
    Minus           reduce using rule 18 (block -> empty .)
    BitNot          reduce using rule 18 (block -> empty .)
    Not             reduce using rule 18 (block -> empty .)
    Integer         reduce using rule 18 (block -> empty .)
    LParen          reduce using rule 18 (block -> empty .)
    Semi            reduce using rule 18 (block -> empty .)


state 91

    (77) postfix -> Identifier LParen expressionlist RParen .

    Mul             reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Div             reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Mod             reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Plus            reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Minus           reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Less            reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Greater         reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    LessEqual       reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    GreaterEqual    reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    NotEqual        reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Equal           reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    BitAnd          reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Xor             reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    BitOr           reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    And             reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Question        reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Or              reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Semi            reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    RParen          reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Comma           reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)
    Colon           reduce using rule 77 (postfix -> Identifier LParen expressionlist RParen .)


state 92

    (16) expressionlist -> expressionlist Comma . expression
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 112
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 93

    (98) conditional -> logical_or Question expression Colon . conditional
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Identifier      shift and go to state 60
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    logical_or                     shift and go to state 19
    conditional                    shift and go to state 113
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 94

    (61) declaration -> type . Identifier
    (62) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 114


state 95

    (56) statement_matched -> LBrace . block RBrace
    (17) block -> . block block_item
    (18) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 115
    empty                          shift and go to state 90

state 96

    (9) function -> type Identifier LParen parameterlist RParen LBrace block RBrace .

    Int             reduce using rule 9 (function -> type Identifier LParen parameterlist RParen LBrace block RBrace .)
    $end            reduce using rule 9 (function -> type Identifier LParen parameterlist RParen LBrace block RBrace .)


state 97

    (17) block -> block block_item .

    RBrace          reduce using rule 17 (block -> block block_item .)
    If              reduce using rule 17 (block -> block block_item .)
    While           reduce using rule 17 (block -> block block_item .)
    For             reduce using rule 17 (block -> block block_item .)
    Do              reduce using rule 17 (block -> block block_item .)
    Return          reduce using rule 17 (block -> block block_item .)
    LBrace          reduce using rule 17 (block -> block block_item .)
    Break           reduce using rule 17 (block -> block block_item .)
    Continue        reduce using rule 17 (block -> block block_item .)
    Int             reduce using rule 17 (block -> block block_item .)
    Identifier      reduce using rule 17 (block -> block block_item .)
    Minus           reduce using rule 17 (block -> block block_item .)
    BitNot          reduce using rule 17 (block -> block block_item .)
    Not             reduce using rule 17 (block -> block block_item .)
    Integer         reduce using rule 17 (block -> block block_item .)
    LParen          reduce using rule 17 (block -> block block_item .)
    Semi            reduce using rule 17 (block -> block block_item .)


state 98

    (19) block_item -> statement .

    RBrace          reduce using rule 19 (block_item -> statement .)
    If              reduce using rule 19 (block_item -> statement .)
    While           reduce using rule 19 (block_item -> statement .)
    For             reduce using rule 19 (block_item -> statement .)
    Do              reduce using rule 19 (block_item -> statement .)
    Return          reduce using rule 19 (block_item -> statement .)
    LBrace          reduce using rule 19 (block_item -> statement .)
    Break           reduce using rule 19 (block_item -> statement .)
    Continue        reduce using rule 19 (block_item -> statement .)
    Int             reduce using rule 19 (block_item -> statement .)
    Identifier      reduce using rule 19 (block_item -> statement .)
    Minus           reduce using rule 19 (block_item -> statement .)
    BitNot          reduce using rule 19 (block_item -> statement .)
    Not             reduce using rule 19 (block_item -> statement .)
    Integer         reduce using rule 19 (block_item -> statement .)
    LParen          reduce using rule 19 (block_item -> statement .)
    Semi            reduce using rule 19 (block_item -> statement .)


state 99

    (20) block_item -> declaration . Semi

    Semi            shift and go to state 116


state 100

    (21) statement -> statement_matched .

    RBrace          reduce using rule 21 (statement -> statement_matched .)
    If              reduce using rule 21 (statement -> statement_matched .)
    While           reduce using rule 21 (statement -> statement_matched .)
    For             reduce using rule 21 (statement -> statement_matched .)
    Do              reduce using rule 21 (statement -> statement_matched .)
    Return          reduce using rule 21 (statement -> statement_matched .)
    LBrace          reduce using rule 21 (statement -> statement_matched .)
    Break           reduce using rule 21 (statement -> statement_matched .)
    Continue        reduce using rule 21 (statement -> statement_matched .)
    Int             reduce using rule 21 (statement -> statement_matched .)
    Identifier      reduce using rule 21 (statement -> statement_matched .)
    Minus           reduce using rule 21 (statement -> statement_matched .)
    BitNot          reduce using rule 21 (statement -> statement_matched .)
    Not             reduce using rule 21 (statement -> statement_matched .)
    Integer         reduce using rule 21 (statement -> statement_matched .)
    LParen          reduce using rule 21 (statement -> statement_matched .)
    Semi            reduce using rule 21 (statement -> statement_matched .)


state 101

    (22) statement -> statement_unmatched .

    RBrace          reduce using rule 22 (statement -> statement_unmatched .)
    If              reduce using rule 22 (statement -> statement_unmatched .)
    While           reduce using rule 22 (statement -> statement_unmatched .)
    For             reduce using rule 22 (statement -> statement_unmatched .)
    Do              reduce using rule 22 (statement -> statement_unmatched .)
    Return          reduce using rule 22 (statement -> statement_unmatched .)
    LBrace          reduce using rule 22 (statement -> statement_unmatched .)
    Break           reduce using rule 22 (statement -> statement_unmatched .)
    Continue        reduce using rule 22 (statement -> statement_unmatched .)
    Int             reduce using rule 22 (statement -> statement_unmatched .)
    Identifier      reduce using rule 22 (statement -> statement_unmatched .)
    Minus           reduce using rule 22 (statement -> statement_unmatched .)
    BitNot          reduce using rule 22 (statement -> statement_unmatched .)
    Not             reduce using rule 22 (statement -> statement_unmatched .)
    Integer         reduce using rule 22 (statement -> statement_unmatched .)
    LParen          reduce using rule 22 (statement -> statement_unmatched .)
    Semi            reduce using rule 22 (statement -> statement_unmatched .)


state 102

    (59) opt_expression -> expression .

    Semi            reduce using rule 59 (opt_expression -> expression .)


state 103

    (23) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (24) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 117


state 104

    (26) statement_matched -> While . LParen expression RParen statement_matched
    (27) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 118


state 105

    (28) statement_matched -> For . LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> For . LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> For . LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> For . LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> For . LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> For . LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> For . LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> For . LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> For . LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> For . LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> For . LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> For . LParen Semi Semi RParen statement_matched
    (30) statement_unmatched -> For . LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For . LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For . LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For . LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For . LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> For . LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> For . LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For . LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> For . LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> For . LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> For . LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> For . LParen Semi Semi RParen statement_unmatched

    LParen          shift and go to state 119


state 106

    (52) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (53) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    statement_matched              shift and go to state 120
    expression                     shift and go to state 102
    statement_unmatched            shift and go to state 121
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 107

    (54) statement_matched -> Return . expression Semi
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 122
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 108

    (55) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 123


state 109

    (57) statement_matched -> Break . Semi

    Semi            shift and go to state 124


state 110

    (58) statement_matched -> Continue . Semi

    Semi            shift and go to state 125


state 111

    (60) opt_expression -> empty .

    Semi            reduce using rule 60 (opt_expression -> empty .)


state 112

    (16) expressionlist -> expressionlist Comma expression .

    RParen          reduce using rule 16 (expressionlist -> expressionlist Comma expression .)
    Comma           reduce using rule 16 (expressionlist -> expressionlist Comma expression .)


state 113

    (98) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 98 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 98 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 98 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 98 (conditional -> logical_or Question expression Colon conditional .)


state 114

    (61) declaration -> type Identifier .
    (62) declaration -> type Identifier . Assign expression

    Semi            reduce using rule 61 (declaration -> type Identifier .)
    Assign          shift and go to state 126


state 115

    (56) statement_matched -> LBrace block . RBrace
    (17) block -> block . block_item
    (19) block_item -> . statement
    (20) block_item -> . declaration Semi
    (21) statement -> . statement_matched
    (22) statement -> . statement_unmatched
    (61) declaration -> . type Identifier
    (62) declaration -> . type Identifier Assign expression
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (7) type -> . Int
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RBrace          shift and go to state 127
    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    block_item                     shift and go to state 97
    statement                      shift and go to state 98
    declaration                    shift and go to state 99
    statement_matched              shift and go to state 100
    statement_unmatched            shift and go to state 101
    type                           shift and go to state 94
    expression                     shift and go to state 102
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 116

    (20) block_item -> declaration Semi .

    RBrace          reduce using rule 20 (block_item -> declaration Semi .)
    If              reduce using rule 20 (block_item -> declaration Semi .)
    While           reduce using rule 20 (block_item -> declaration Semi .)
    For             reduce using rule 20 (block_item -> declaration Semi .)
    Do              reduce using rule 20 (block_item -> declaration Semi .)
    Return          reduce using rule 20 (block_item -> declaration Semi .)
    LBrace          reduce using rule 20 (block_item -> declaration Semi .)
    Break           reduce using rule 20 (block_item -> declaration Semi .)
    Continue        reduce using rule 20 (block_item -> declaration Semi .)
    Int             reduce using rule 20 (block_item -> declaration Semi .)
    Identifier      reduce using rule 20 (block_item -> declaration Semi .)
    Minus           reduce using rule 20 (block_item -> declaration Semi .)
    BitNot          reduce using rule 20 (block_item -> declaration Semi .)
    Not             reduce using rule 20 (block_item -> declaration Semi .)
    Integer         reduce using rule 20 (block_item -> declaration Semi .)
    LParen          reduce using rule 20 (block_item -> declaration Semi .)
    Semi            reduce using rule 20 (block_item -> declaration Semi .)


state 117

    (23) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (24) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> If LParen . expression RParen statement
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 128
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 118

    (26) statement_matched -> While LParen . expression RParen statement_matched
    (27) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 129
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 119

    (28) statement_matched -> For LParen . expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> For LParen . declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> For LParen . Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> For LParen . expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> For LParen . declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> For LParen . expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> For LParen . declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> For LParen . expression Semi Semi RParen statement_matched
    (43) statement_matched -> For LParen . declaration Semi Semi RParen statement_matched
    (46) statement_matched -> For LParen . Semi expression Semi RParen statement_matched
    (48) statement_matched -> For LParen . Semi Semi expression RParen statement_matched
    (50) statement_matched -> For LParen . Semi Semi RParen statement_matched
    (30) statement_unmatched -> For LParen . expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> For LParen . declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> For LParen . Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen . expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen . declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen . expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> For LParen . declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For LParen . expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> For LParen . declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> For LParen . Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> For LParen . Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> For LParen . Semi Semi RParen statement_unmatched
    (63) expression -> . assignment
    (61) declaration -> . type Identifier
    (62) declaration -> . type Identifier Assign expression
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (7) type -> . Int
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Semi            shift and go to state 131
    Identifier      shift and go to state 15
    Int             shift and go to state 6
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 130
    declaration                    shift and go to state 132
    assignment                     shift and go to state 17
    type                           shift and go to state 94
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 120

    (52) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 133


state 121

    (53) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 134


state 122

    (54) statement_matched -> Return expression . Semi

    Semi            shift and go to state 135


state 123

    (55) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 55 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 55 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 55 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 55 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 55 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 55 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 55 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 55 (statement_matched -> opt_expression Semi .)


state 124

    (57) statement_matched -> Break Semi .

    RBrace          reduce using rule 57 (statement_matched -> Break Semi .)
    If              reduce using rule 57 (statement_matched -> Break Semi .)
    While           reduce using rule 57 (statement_matched -> Break Semi .)
    For             reduce using rule 57 (statement_matched -> Break Semi .)
    Do              reduce using rule 57 (statement_matched -> Break Semi .)
    Return          reduce using rule 57 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 57 (statement_matched -> Break Semi .)
    Break           reduce using rule 57 (statement_matched -> Break Semi .)
    Continue        reduce using rule 57 (statement_matched -> Break Semi .)
    Int             reduce using rule 57 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 57 (statement_matched -> Break Semi .)
    Minus           reduce using rule 57 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 57 (statement_matched -> Break Semi .)
    Not             reduce using rule 57 (statement_matched -> Break Semi .)
    Integer         reduce using rule 57 (statement_matched -> Break Semi .)
    LParen          reduce using rule 57 (statement_matched -> Break Semi .)
    Semi            reduce using rule 57 (statement_matched -> Break Semi .)
    Else            reduce using rule 57 (statement_matched -> Break Semi .)


state 125

    (58) statement_matched -> Continue Semi .

    RBrace          reduce using rule 58 (statement_matched -> Continue Semi .)
    If              reduce using rule 58 (statement_matched -> Continue Semi .)
    While           reduce using rule 58 (statement_matched -> Continue Semi .)
    For             reduce using rule 58 (statement_matched -> Continue Semi .)
    Do              reduce using rule 58 (statement_matched -> Continue Semi .)
    Return          reduce using rule 58 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 58 (statement_matched -> Continue Semi .)
    Break           reduce using rule 58 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 58 (statement_matched -> Continue Semi .)
    Int             reduce using rule 58 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 58 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 58 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 58 (statement_matched -> Continue Semi .)
    Not             reduce using rule 58 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 58 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 58 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 58 (statement_matched -> Continue Semi .)
    Else            reduce using rule 58 (statement_matched -> Continue Semi .)


state 126

    (62) declaration -> type Identifier Assign . expression
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 136
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 127

    (56) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 56 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 56 (statement_matched -> LBrace block RBrace .)


state 128

    (23) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (24) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 137


state 129

    (26) statement_matched -> While LParen expression . RParen statement_matched
    (27) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 138


state 130

    (28) statement_matched -> For LParen expression . Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> For LParen expression . Semi Semi expression RParen statement_matched
    (38) statement_matched -> For LParen expression . Semi expression Semi RParen statement_matched
    (42) statement_matched -> For LParen expression . Semi Semi RParen statement_matched
    (30) statement_unmatched -> For LParen expression . Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression . Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression . Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For LParen expression . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 139


state 131

    (32) statement_matched -> For LParen Semi . expression Semi expression RParen statement_matched
    (46) statement_matched -> For LParen Semi . expression Semi RParen statement_matched
    (48) statement_matched -> For LParen Semi . Semi expression RParen statement_matched
    (50) statement_matched -> For LParen Semi . Semi RParen statement_matched
    (33) statement_unmatched -> For LParen Semi . expression Semi expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen Semi . expression Semi RParen statement_unmatched
    (49) statement_unmatched -> For LParen Semi . Semi expression RParen statement_unmatched
    (51) statement_unmatched -> For LParen Semi . Semi RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Semi            shift and go to state 140
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 141
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 132

    (29) statement_matched -> For LParen declaration . Semi expression Semi expression RParen statement_matched
    (35) statement_matched -> For LParen declaration . Semi Semi expression RParen statement_matched
    (39) statement_matched -> For LParen declaration . Semi expression Semi RParen statement_matched
    (43) statement_matched -> For LParen declaration . Semi Semi RParen statement_matched
    (31) statement_unmatched -> For LParen declaration . Semi expression Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration . Semi Semi expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration . Semi expression Semi RParen statement_unmatched
    (45) statement_unmatched -> For LParen declaration . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 142


state 133

    (52) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 143


state 134

    (53) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 144


state 135

    (54) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 54 (statement_matched -> Return expression Semi .)
    If              reduce using rule 54 (statement_matched -> Return expression Semi .)
    While           reduce using rule 54 (statement_matched -> Return expression Semi .)
    For             reduce using rule 54 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 54 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 54 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 54 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 54 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 54 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 54 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 54 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 54 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 54 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 54 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 54 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 54 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 54 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 54 (statement_matched -> Return expression Semi .)


state 136

    (62) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 62 (declaration -> type Identifier Assign expression .)


state 137

    (23) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (24) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (25) statement_unmatched -> If LParen expression RParen . statement
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (21) statement -> . statement_matched
    (22) statement -> . statement_unmatched
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 145
    statement_unmatched            shift and go to state 101
    statement                      shift and go to state 146
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 138

    (26) statement_matched -> While LParen expression RParen . statement_matched
    (27) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 147
    statement_unmatched            shift and go to state 148
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 139

    (28) statement_matched -> For LParen expression Semi . expression Semi expression RParen statement_matched
    (34) statement_matched -> For LParen expression Semi . Semi expression RParen statement_matched
    (38) statement_matched -> For LParen expression Semi . expression Semi RParen statement_matched
    (42) statement_matched -> For LParen expression Semi . Semi RParen statement_matched
    (30) statement_unmatched -> For LParen expression Semi . expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> For LParen expression Semi . Semi expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression Semi . expression Semi RParen statement_unmatched
    (44) statement_unmatched -> For LParen expression Semi . Semi RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Semi            shift and go to state 150
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 149
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 140

    (48) statement_matched -> For LParen Semi Semi . expression RParen statement_matched
    (50) statement_matched -> For LParen Semi Semi . RParen statement_matched
    (49) statement_unmatched -> For LParen Semi Semi . expression RParen statement_unmatched
    (51) statement_unmatched -> For LParen Semi Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 152
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 151
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 141

    (32) statement_matched -> For LParen Semi expression . Semi expression RParen statement_matched
    (46) statement_matched -> For LParen Semi expression . Semi RParen statement_matched
    (33) statement_unmatched -> For LParen Semi expression . Semi expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 153


state 142

    (29) statement_matched -> For LParen declaration Semi . expression Semi expression RParen statement_matched
    (35) statement_matched -> For LParen declaration Semi . Semi expression RParen statement_matched
    (39) statement_matched -> For LParen declaration Semi . expression Semi RParen statement_matched
    (43) statement_matched -> For LParen declaration Semi . Semi RParen statement_matched
    (31) statement_unmatched -> For LParen declaration Semi . expression Semi expression RParen statement_unmatched
    (37) statement_unmatched -> For LParen declaration Semi . Semi expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration Semi . expression Semi RParen statement_unmatched
    (45) statement_unmatched -> For LParen declaration Semi . Semi RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Semi            shift and go to state 154
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 155
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 143

    (52) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 156
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 144

    (53) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 157
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 145

    (23) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (24) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (21) statement -> statement_matched .

    Else            shift and go to state 158
    RBrace          reduce using rule 21 (statement -> statement_matched .)
    If              reduce using rule 21 (statement -> statement_matched .)
    While           reduce using rule 21 (statement -> statement_matched .)
    For             reduce using rule 21 (statement -> statement_matched .)
    Do              reduce using rule 21 (statement -> statement_matched .)
    Return          reduce using rule 21 (statement -> statement_matched .)
    LBrace          reduce using rule 21 (statement -> statement_matched .)
    Break           reduce using rule 21 (statement -> statement_matched .)
    Continue        reduce using rule 21 (statement -> statement_matched .)
    Int             reduce using rule 21 (statement -> statement_matched .)
    Identifier      reduce using rule 21 (statement -> statement_matched .)
    Minus           reduce using rule 21 (statement -> statement_matched .)
    BitNot          reduce using rule 21 (statement -> statement_matched .)
    Not             reduce using rule 21 (statement -> statement_matched .)
    Integer         reduce using rule 21 (statement -> statement_matched .)
    LParen          reduce using rule 21 (statement -> statement_matched .)
    Semi            reduce using rule 21 (statement -> statement_matched .)


state 146

    (25) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 25 (statement_unmatched -> If LParen expression RParen statement .)


state 147

    (26) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 26 (statement_matched -> While LParen expression RParen statement_matched .)


state 148

    (27) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 27 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 149

    (28) statement_matched -> For LParen expression Semi expression . Semi expression RParen statement_matched
    (38) statement_matched -> For LParen expression Semi expression . Semi RParen statement_matched
    (30) statement_unmatched -> For LParen expression Semi expression . Semi expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 159


state 150

    (34) statement_matched -> For LParen expression Semi Semi . expression RParen statement_matched
    (42) statement_matched -> For LParen expression Semi Semi . RParen statement_matched
    (36) statement_unmatched -> For LParen expression Semi Semi . expression RParen statement_unmatched
    (44) statement_unmatched -> For LParen expression Semi Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 161
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 160
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 151

    (48) statement_matched -> For LParen Semi Semi expression . RParen statement_matched
    (49) statement_unmatched -> For LParen Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 162


state 152

    (50) statement_matched -> For LParen Semi Semi RParen . statement_matched
    (51) statement_unmatched -> For LParen Semi Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    statement_matched              shift and go to state 163
    statement_unmatched            shift and go to state 164
    expression                     shift and go to state 102
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 153

    (32) statement_matched -> For LParen Semi expression Semi . expression RParen statement_matched
    (46) statement_matched -> For LParen Semi expression Semi . RParen statement_matched
    (33) statement_unmatched -> For LParen Semi expression Semi . expression RParen statement_unmatched
    (47) statement_unmatched -> For LParen Semi expression Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 166
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 165
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 154

    (35) statement_matched -> For LParen declaration Semi Semi . expression RParen statement_matched
    (43) statement_matched -> For LParen declaration Semi Semi . RParen statement_matched
    (37) statement_unmatched -> For LParen declaration Semi Semi . expression RParen statement_unmatched
    (45) statement_unmatched -> For LParen declaration Semi Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 168
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 167
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 155

    (29) statement_matched -> For LParen declaration Semi expression . Semi expression RParen statement_matched
    (39) statement_matched -> For LParen declaration Semi expression . Semi RParen statement_matched
    (31) statement_unmatched -> For LParen declaration Semi expression . Semi expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 169


state 156

    (52) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 170


state 157

    (53) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 171


state 158

    (23) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (24) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 172
    statement_unmatched            shift and go to state 173
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 159

    (28) statement_matched -> For LParen expression Semi expression Semi . expression RParen statement_matched
    (38) statement_matched -> For LParen expression Semi expression Semi . RParen statement_matched
    (30) statement_unmatched -> For LParen expression Semi expression Semi . expression RParen statement_unmatched
    (40) statement_unmatched -> For LParen expression Semi expression Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 175
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 174
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 160

    (34) statement_matched -> For LParen expression Semi Semi expression . RParen statement_matched
    (36) statement_unmatched -> For LParen expression Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 176


state 161

    (42) statement_matched -> For LParen expression Semi Semi RParen . statement_matched
    (44) statement_unmatched -> For LParen expression Semi Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 177
    statement_unmatched            shift and go to state 178
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 162

    (48) statement_matched -> For LParen Semi Semi expression RParen . statement_matched
    (49) statement_unmatched -> For LParen Semi Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 179
    statement_unmatched            shift and go to state 180
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 163

    (50) statement_matched -> For LParen Semi Semi RParen statement_matched .

    RBrace          reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    If              reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    While           reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    For             reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Do              reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Return          reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Break           reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Continue        reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Int             reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Minus           reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Not             reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Integer         reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LParen          reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Semi            reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Else            reduce using rule 50 (statement_matched -> For LParen Semi Semi RParen statement_matched .)


state 164

    (51) statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    If              reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    While           reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    For             reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 51 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)


state 165

    (32) statement_matched -> For LParen Semi expression Semi expression . RParen statement_matched
    (33) statement_unmatched -> For LParen Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 181


state 166

    (46) statement_matched -> For LParen Semi expression Semi RParen . statement_matched
    (47) statement_unmatched -> For LParen Semi expression Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 182
    statement_unmatched            shift and go to state 183
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 167

    (35) statement_matched -> For LParen declaration Semi Semi expression . RParen statement_matched
    (37) statement_unmatched -> For LParen declaration Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 184


state 168

    (43) statement_matched -> For LParen declaration Semi Semi RParen . statement_matched
    (45) statement_unmatched -> For LParen declaration Semi Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    statement_matched              shift and go to state 185
    statement_unmatched            shift and go to state 186
    expression                     shift and go to state 102
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 169

    (29) statement_matched -> For LParen declaration Semi expression Semi . expression RParen statement_matched
    (39) statement_matched -> For LParen declaration Semi expression Semi . RParen statement_matched
    (31) statement_unmatched -> For LParen declaration Semi expression Semi . expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen declaration Semi expression Semi . RParen statement_unmatched
    (63) expression -> . assignment
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    RParen          shift and go to state 188
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 187
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 170

    (52) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 189


state 171

    (53) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 190


state 172

    (23) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 23 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 173

    (24) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 174

    (28) statement_matched -> For LParen expression Semi expression Semi expression . RParen statement_matched
    (30) statement_unmatched -> For LParen expression Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 191


state 175

    (38) statement_matched -> For LParen expression Semi expression Semi RParen . statement_matched
    (40) statement_unmatched -> For LParen expression Semi expression Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 192
    statement_unmatched            shift and go to state 193
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 176

    (34) statement_matched -> For LParen expression Semi Semi expression RParen . statement_matched
    (36) statement_unmatched -> For LParen expression Semi Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 194
    statement_unmatched            shift and go to state 195
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 177

    (42) statement_matched -> For LParen expression Semi Semi RParen statement_matched .

    RBrace          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    If              reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    While           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    For             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Do              reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Return          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Break           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Continue        reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Int             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Minus           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Not             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Integer         reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LParen          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Semi            reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Else            reduce using rule 42 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)


state 178

    (44) statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    If              reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    While           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    For             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)


state 179

    (48) statement_matched -> For LParen Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    If              reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    While           reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    For             reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 48 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)


state 180

    (49) statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 49 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)


state 181

    (32) statement_matched -> For LParen Semi expression Semi expression RParen . statement_matched
    (33) statement_unmatched -> For LParen Semi expression Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 196
    statement_unmatched            shift and go to state 197
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 182

    (46) statement_matched -> For LParen Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    If              reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    While           reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    For             reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 46 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)


state 183

    (47) statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 47 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)


state 184

    (35) statement_matched -> For LParen declaration Semi Semi expression RParen . statement_matched
    (37) statement_unmatched -> For LParen declaration Semi Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 198
    statement_unmatched            shift and go to state 199
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 185

    (43) statement_matched -> For LParen declaration Semi Semi RParen statement_matched .

    RBrace          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    If              reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    While           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    For             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Do              reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Return          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Break           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Continue        reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Int             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Minus           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Not             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Integer         reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LParen          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Semi            reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Else            reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)


state 186

    (45) statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    If              reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    While           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    For             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)


state 187

    (29) statement_matched -> For LParen declaration Semi expression Semi expression . RParen statement_matched
    (31) statement_unmatched -> For LParen declaration Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 200


state 188

    (39) statement_matched -> For LParen declaration Semi expression Semi RParen . statement_matched
    (41) statement_unmatched -> For LParen declaration Semi expression Semi RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 201
    statement_unmatched            shift and go to state 202
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 189

    (52) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 52 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 190

    (53) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 53 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 191

    (28) statement_matched -> For LParen expression Semi expression Semi expression RParen . statement_matched
    (30) statement_unmatched -> For LParen expression Semi expression Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 203
    statement_unmatched            shift and go to state 204
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 192

    (38) statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    If              reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    While           reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    For             reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 38 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)


state 193

    (40) statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 40 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)


state 194

    (34) statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    If              reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    While           reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    For             reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 34 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)


state 195

    (36) statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 36 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)


state 196

    (32) statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 32 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)


state 197

    (33) statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 33 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)


state 198

    (35) statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    If              reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    While           reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    For             reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 35 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)


state 199

    (37) statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 37 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)


state 200

    (29) statement_matched -> For LParen declaration Semi expression Semi expression RParen . statement_matched
    (31) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen . statement_unmatched
    (23) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (26) statement_matched -> . While LParen expression RParen statement_matched
    (28) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (29) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (32) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (34) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (35) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (38) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (39) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (46) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (48) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (50) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (52) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (54) statement_matched -> . Return expression Semi
    (55) statement_matched -> . opt_expression Semi
    (56) statement_matched -> . LBrace block RBrace
    (57) statement_matched -> . Break Semi
    (58) statement_matched -> . Continue Semi
    (24) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (25) statement_unmatched -> . If LParen expression RParen statement
    (27) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (31) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (33) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (36) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (37) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (40) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (41) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (47) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (51) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (59) opt_expression -> . expression
    (60) opt_expression -> . empty
    (63) expression -> . assignment
    (1) empty -> .
    (64) assignment -> . conditional
    (81) assignment -> . Identifier Assign expression
    (65) conditional -> . logical_or
    (98) conditional -> . logical_or Question expression Colon conditional
    (66) logical_or -> . logical_and
    (82) logical_or -> . logical_or Or logical_and
    (67) logical_and -> . bit_or
    (83) logical_and -> . logical_and And bit_or
    (68) bit_or -> . xor
    (84) bit_or -> . bit_or BitOr xor
    (69) xor -> . bit_and
    (85) xor -> . xor Xor bit_and
    (70) bit_and -> . equality
    (86) bit_and -> . bit_and BitAnd equality
    (71) equality -> . relational
    (87) equality -> . equality NotEqual relational
    (88) equality -> . equality Equal relational
    (72) relational -> . additive
    (89) relational -> . relational Less additive
    (90) relational -> . relational Greater additive
    (91) relational -> . relational LessEqual additive
    (92) relational -> . relational GreaterEqual additive
    (73) additive -> . multiplicative
    (93) additive -> . additive Plus multiplicative
    (94) additive -> . additive Minus multiplicative
    (74) multiplicative -> . unary
    (95) multiplicative -> . multiplicative Mul unary
    (96) multiplicative -> . multiplicative Div unary
    (97) multiplicative -> . multiplicative Mod unary
    (75) unary -> . postfix
    (78) unary -> . Minus unary
    (79) unary -> . BitNot unary
    (80) unary -> . Not unary
    (76) postfix -> . primary
    (77) postfix -> . Identifier LParen expressionlist RParen
    (99) primary -> . Integer
    (100) primary -> . Identifier
    (101) primary -> . LParen expression RParen

    If              shift and go to state 103
    While           shift and go to state 104
    For             shift and go to state 105
    Do              shift and go to state 106
    Return          shift and go to state 107
    LBrace          shift and go to state 95
    Break           shift and go to state 109
    Continue        shift and go to state 110
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 15
    Minus           shift and go to state 28
    BitNot          shift and go to state 31
    Not             shift and go to state 32
    Integer         shift and go to state 35
    LParen          shift and go to state 34

    expression                     shift and go to state 102
    statement_matched              shift and go to state 205
    statement_unmatched            shift and go to state 206
    opt_expression                 shift and go to state 108
    empty                          shift and go to state 111
    assignment                     shift and go to state 17
    conditional                    shift and go to state 18
    logical_or                     shift and go to state 19
    logical_and                    shift and go to state 20
    bit_or                         shift and go to state 21
    xor                            shift and go to state 22
    bit_and                        shift and go to state 23
    equality                       shift and go to state 24
    relational                     shift and go to state 25
    additive                       shift and go to state 26
    multiplicative                 shift and go to state 27
    unary                          shift and go to state 29
    postfix                        shift and go to state 30
    primary                        shift and go to state 33

state 201

    (39) statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    If              reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    While           reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    For             reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 39 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)


state 202

    (41) statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 41 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)


state 203

    (28) statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 28 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)


state 204

    (30) statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 30 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)


state 205

    (29) statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 29 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)


state 206

    (31) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 31 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)

