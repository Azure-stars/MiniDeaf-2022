Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> empty
Rule 3     program -> program function
Rule 4     program -> program globaldeclaration
Rule 5     globaldeclaration -> type Identifier Semi
Rule 6     globaldeclaration -> type Identifier Assign expression Semi
Rule 7     globaldeclaration -> type Identifier indexlist Semi
Rule 8     globaldeclaration -> type Identifier indexlist Assign LBrace set RBrace Semi
Rule 9     set -> empty
Rule 10    set -> Integer
Rule 11    set -> set Comma Integer
Rule 12    type -> Int
Rule 13    function -> type Identifier LParen parameterlist RParen Semi
Rule 14    function -> type Identifier LParen parameterlist RParen LBrace block RBrace
Rule 15    parameterlist -> empty
Rule 16    parameterlist -> parameter
Rule 17    parameterlist -> parameterlist Comma parameter
Rule 18    parameter -> type Identifier
Rule 19    parameter -> type Identifier indexlist
Rule 20    parameter -> type Identifier LMidBrace RMidBrace
Rule 21    parameter -> type Identifier LMidBrace RMidBrace indexlist
Rule 22    expressionlist -> empty
Rule 23    expressionlist -> expression
Rule 24    expressionlist -> expressionlist Comma expression
Rule 25    block -> block block_item
Rule 26    block -> empty
Rule 27    block_item -> statement
Rule 28    block_item -> declaration Semi
Rule 29    statement -> statement_matched
Rule 30    statement -> statement_unmatched
Rule 31    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 32    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 33    statement_unmatched -> If LParen expression RParen statement
Rule 34    statement_matched -> While LParen expression RParen statement_matched
Rule 35    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 36    statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched
Rule 37    statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched
Rule 38    statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched
Rule 39    statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched
Rule 40    statement_matched -> For LParen Semi expression Semi expression RParen statement_matched
Rule 41    statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched
Rule 42    statement_matched -> For LParen expression Semi Semi expression RParen statement_matched
Rule 43    statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched
Rule 44    statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched
Rule 45    statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched
Rule 46    statement_matched -> For LParen expression Semi expression Semi RParen statement_matched
Rule 47    statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched
Rule 48    statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched
Rule 49    statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched
Rule 50    statement_matched -> For LParen expression Semi Semi RParen statement_matched
Rule 51    statement_matched -> For LParen declaration Semi Semi RParen statement_matched
Rule 52    statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched
Rule 53    statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched
Rule 54    statement_matched -> For LParen Semi expression Semi RParen statement_matched
Rule 55    statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched
Rule 56    statement_matched -> For LParen Semi Semi expression RParen statement_matched
Rule 57    statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched
Rule 58    statement_matched -> For LParen Semi Semi RParen statement_matched
Rule 59    statement_unmatched -> For LParen Semi Semi RParen statement_unmatched
Rule 60    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 61    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 62    statement_matched -> Return expression Semi
Rule 63    statement_matched -> opt_expression Semi
Rule 64    statement_matched -> LBrace block RBrace
Rule 65    statement_matched -> Break Semi
Rule 66    statement_matched -> Continue Semi
Rule 67    opt_expression -> expression
Rule 68    opt_expression -> empty
Rule 69    declaration -> type Identifier
Rule 70    declaration -> type Identifier Assign expression
Rule 71    declaration -> type Identifier indexlist
Rule 72    declaration -> type Identifier indexlist Assign LBrace set RBrace
Rule 73    indexlist -> indexlist LMidBrace Integer RMidBrace
Rule 74    indexlist -> LMidBrace Integer RMidBrace
Rule 75    expression -> assignment
Rule 76    assignment -> conditional
Rule 77    conditional -> logical_or
Rule 78    logical_or -> logical_and
Rule 79    logical_and -> bit_or
Rule 80    bit_or -> xor
Rule 81    xor -> bit_and
Rule 82    bit_and -> equality
Rule 83    equality -> relational
Rule 84    relational -> additive
Rule 85    additive -> multiplicative
Rule 86    multiplicative -> unary
Rule 87    unary -> postfix
Rule 88    postfix -> primary
Rule 89    postfix -> Identifier LParen expressionlist RParen
Rule 90    postfix -> postfix_array LMidBrace expression RMidBrace
Rule 91    postfix_array -> postfix_array LMidBrace expression RMidBrace
Rule 92    postfix_array -> primary
Rule 93    unary -> Minus unary
Rule 94    unary -> BitNot unary
Rule 95    unary -> Not unary
Rule 96    assignment -> postfix Assign expression
Rule 97    logical_or -> logical_or Or logical_and
Rule 98    logical_and -> logical_and And bit_or
Rule 99    bit_or -> bit_or BitOr xor
Rule 100   xor -> xor Xor bit_and
Rule 101   bit_and -> bit_and BitAnd equality
Rule 102   equality -> equality NotEqual relational
Rule 103   equality -> equality Equal relational
Rule 104   relational -> relational Less additive
Rule 105   relational -> relational Greater additive
Rule 106   relational -> relational LessEqual additive
Rule 107   relational -> relational GreaterEqual additive
Rule 108   additive -> additive Plus multiplicative
Rule 109   additive -> additive Minus multiplicative
Rule 110   multiplicative -> multiplicative Mul unary
Rule 111   multiplicative -> multiplicative Div unary
Rule 112   multiplicative -> multiplicative Mod unary
Rule 113   conditional -> logical_or Question expression Colon conditional
Rule 114   primary -> Integer
Rule 115   primary -> Identifier
Rule 116   primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 98
Assign               : 6 8 70 72 96
BitAnd               : 101
BitNot               : 94
BitOr                : 99
Break                : 65
Colon                : 113
Comma                : 11 17 24
Continue             : 66
Div                  : 111
Do                   : 60 61
Else                 : 31 32
Equal                : 103
For                  : 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59
Greater              : 105
GreaterEqual         : 107
Identifier           : 5 6 7 8 13 14 18 19 20 21 69 70 71 72 89 115
If                   : 31 32 33
Int                  : 12
Integer              : 10 11 73 74 114
LBrace               : 8 14 64 72
LMidBrace            : 20 21 73 74 90 91
LParen               : 13 14 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 89 116
Less                 : 104
LessEqual            : 106
Minus                : 93 109
Mod                  : 112
Mul                  : 110
Not                  : 95
NotEqual             : 102
Or                   : 97
Plus                 : 108
Question             : 113
RBrace               : 8 14 64 72
RMidBrace            : 20 21 73 74 90 91
RParen               : 13 14 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 89 116
Return               : 62
Semi                 : 5 6 7 8 13 28 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 61 62 63 65 66
While                : 34 35 60 61
Xor                  : 100
error                : 

Nonterminals, with rules where they appear

additive             : 84 104 105 106 107 108 109
assignment           : 75
bit_and              : 81 100 101
bit_or               : 79 98 99
block                : 14 25 64
block_item           : 25
conditional          : 76 113
declaration          : 28 37 39 43 45 47 49 51 53
empty                : 2 9 15 22 26 68
equality             : 82 101 102 103
expression           : 6 23 24 31 32 33 34 35 36 36 36 37 37 38 38 38 39 39 40 40 41 41 42 42 43 44 44 45 46 46 47 48 48 49 50 52 54 55 56 57 60 61 62 67 70 90 91 96 113 116
expressionlist       : 24 89
function             : 3
globaldeclaration    : 4
indexlist            : 7 8 19 21 71 72 73
logical_and          : 78 97 98
logical_or           : 77 97 113
multiplicative       : 85 108 109 110 111 112
opt_expression       : 63
parameter            : 16 17
parameterlist        : 13 14 17
postfix              : 87 96
postfix_array        : 90 91
primary              : 88 92
program              : 3 4 0
relational           : 83 102 103 104 105 106 107
set                  : 8 11 72
statement            : 27 33
statement_matched    : 29 31 31 32 34 36 37 40 42 43 46 47 50 51 54 56 58 60
statement_unmatched  : 30 32 35 38 39 41 44 45 48 49 52 53 55 57 59 61
type                 : 5 6 7 8 13 14 18 19 20 21 69 70 71 72
unary                : 86 93 94 95 110 111 112
xor                  : 80 99 100

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . empty
    (3) program -> . program function
    (4) program -> . program globaldeclaration
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (3) program -> program . function
    (4) program -> program . globaldeclaration
    (13) function -> . type Identifier LParen parameterlist RParen Semi
    (14) function -> . type Identifier LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> . type Identifier Semi
    (6) globaldeclaration -> . type Identifier Assign expression Semi
    (7) globaldeclaration -> . type Identifier indexlist Semi
    (8) globaldeclaration -> . type Identifier indexlist Assign LBrace set RBrace Semi
    (12) type -> . Int

    Int             shift and go to state 6

    function                       shift and go to state 3
    globaldeclaration              shift and go to state 4
    type                           shift and go to state 5

state 2

    (2) program -> empty .

    Int             reduce using rule 2 (program -> empty .)
    $end            reduce using rule 2 (program -> empty .)


state 3

    (3) program -> program function .

    Int             reduce using rule 3 (program -> program function .)
    $end            reduce using rule 3 (program -> program function .)


state 4

    (4) program -> program globaldeclaration .

    Int             reduce using rule 4 (program -> program globaldeclaration .)
    $end            reduce using rule 4 (program -> program globaldeclaration .)


state 5

    (13) function -> type . Identifier LParen parameterlist RParen Semi
    (14) function -> type . Identifier LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> type . Identifier Semi
    (6) globaldeclaration -> type . Identifier Assign expression Semi
    (7) globaldeclaration -> type . Identifier indexlist Semi
    (8) globaldeclaration -> type . Identifier indexlist Assign LBrace set RBrace Semi

    Identifier      shift and go to state 7


state 6

    (12) type -> Int .

    Identifier      reduce using rule 12 (type -> Int .)


state 7

    (13) function -> type Identifier . LParen parameterlist RParen Semi
    (14) function -> type Identifier . LParen parameterlist RParen LBrace block RBrace
    (5) globaldeclaration -> type Identifier . Semi
    (6) globaldeclaration -> type Identifier . Assign expression Semi
    (7) globaldeclaration -> type Identifier . indexlist Semi
    (8) globaldeclaration -> type Identifier . indexlist Assign LBrace set RBrace Semi
    (73) indexlist -> . indexlist LMidBrace Integer RMidBrace
    (74) indexlist -> . LMidBrace Integer RMidBrace

    LParen          shift and go to state 8
    Semi            shift and go to state 9
    Assign          shift and go to state 10
    LMidBrace       shift and go to state 12

    indexlist                      shift and go to state 11

state 8

    (13) function -> type Identifier LParen . parameterlist RParen Semi
    (14) function -> type Identifier LParen . parameterlist RParen LBrace block RBrace
    (15) parameterlist -> . empty
    (16) parameterlist -> . parameter
    (17) parameterlist -> . parameterlist Comma parameter
    (1) empty -> .
    (18) parameter -> . type Identifier
    (19) parameter -> . type Identifier indexlist
    (20) parameter -> . type Identifier LMidBrace RMidBrace
    (21) parameter -> . type Identifier LMidBrace RMidBrace indexlist
    (12) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 6

    type                           shift and go to state 13
    parameterlist                  shift and go to state 14
    empty                          shift and go to state 15
    parameter                      shift and go to state 16

state 9

    (5) globaldeclaration -> type Identifier Semi .

    Int             reduce using rule 5 (globaldeclaration -> type Identifier Semi .)
    $end            reduce using rule 5 (globaldeclaration -> type Identifier Semi .)


state 10

    (6) globaldeclaration -> type Identifier Assign . expression Semi
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 18
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 11

    (7) globaldeclaration -> type Identifier indexlist . Semi
    (8) globaldeclaration -> type Identifier indexlist . Assign LBrace set RBrace Semi
    (73) indexlist -> indexlist . LMidBrace Integer RMidBrace

    Semi            shift and go to state 39
    Assign          shift and go to state 40
    LMidBrace       shift and go to state 41


state 12

    (74) indexlist -> LMidBrace . Integer RMidBrace

    Integer         shift and go to state 42


state 13

    (18) parameter -> type . Identifier
    (19) parameter -> type . Identifier indexlist
    (20) parameter -> type . Identifier LMidBrace RMidBrace
    (21) parameter -> type . Identifier LMidBrace RMidBrace indexlist

    Identifier      shift and go to state 43


state 14

    (13) function -> type Identifier LParen parameterlist . RParen Semi
    (14) function -> type Identifier LParen parameterlist . RParen LBrace block RBrace
    (17) parameterlist -> parameterlist . Comma parameter

    RParen          shift and go to state 44
    Comma           shift and go to state 45


state 15

    (15) parameterlist -> empty .

    RParen          reduce using rule 15 (parameterlist -> empty .)
    Comma           reduce using rule 15 (parameterlist -> empty .)


state 16

    (16) parameterlist -> parameter .

    RParen          reduce using rule 16 (parameterlist -> parameter .)
    Comma           reduce using rule 16 (parameterlist -> parameter .)


state 17

    (89) postfix -> Identifier . LParen expressionlist RParen
    (115) primary -> Identifier .

    LParen          shift and go to state 46
    Assign          reduce using rule 115 (primary -> Identifier .)
    Mul             reduce using rule 115 (primary -> Identifier .)
    Div             reduce using rule 115 (primary -> Identifier .)
    Mod             reduce using rule 115 (primary -> Identifier .)
    Plus            reduce using rule 115 (primary -> Identifier .)
    Minus           reduce using rule 115 (primary -> Identifier .)
    Less            reduce using rule 115 (primary -> Identifier .)
    Greater         reduce using rule 115 (primary -> Identifier .)
    LessEqual       reduce using rule 115 (primary -> Identifier .)
    GreaterEqual    reduce using rule 115 (primary -> Identifier .)
    NotEqual        reduce using rule 115 (primary -> Identifier .)
    Equal           reduce using rule 115 (primary -> Identifier .)
    BitAnd          reduce using rule 115 (primary -> Identifier .)
    Xor             reduce using rule 115 (primary -> Identifier .)
    BitOr           reduce using rule 115 (primary -> Identifier .)
    And             reduce using rule 115 (primary -> Identifier .)
    Question        reduce using rule 115 (primary -> Identifier .)
    Or              reduce using rule 115 (primary -> Identifier .)
    Semi            reduce using rule 115 (primary -> Identifier .)
    LMidBrace       reduce using rule 115 (primary -> Identifier .)
    RParen          reduce using rule 115 (primary -> Identifier .)
    Comma           reduce using rule 115 (primary -> Identifier .)
    Colon           reduce using rule 115 (primary -> Identifier .)
    RMidBrace       reduce using rule 115 (primary -> Identifier .)


state 18

    (6) globaldeclaration -> type Identifier Assign expression . Semi

    Semi            shift and go to state 47


state 19

    (75) expression -> assignment .

    Semi            reduce using rule 75 (expression -> assignment .)
    RParen          reduce using rule 75 (expression -> assignment .)
    Comma           reduce using rule 75 (expression -> assignment .)
    Colon           reduce using rule 75 (expression -> assignment .)
    RMidBrace       reduce using rule 75 (expression -> assignment .)


state 20

    (76) assignment -> conditional .

    Semi            reduce using rule 76 (assignment -> conditional .)
    RParen          reduce using rule 76 (assignment -> conditional .)
    Comma           reduce using rule 76 (assignment -> conditional .)
    Colon           reduce using rule 76 (assignment -> conditional .)
    RMidBrace       reduce using rule 76 (assignment -> conditional .)


state 21

    (96) assignment -> postfix . Assign expression
    (87) unary -> postfix .

    Assign          shift and go to state 48
    Mul             reduce using rule 87 (unary -> postfix .)
    Div             reduce using rule 87 (unary -> postfix .)
    Mod             reduce using rule 87 (unary -> postfix .)
    Plus            reduce using rule 87 (unary -> postfix .)
    Minus           reduce using rule 87 (unary -> postfix .)
    Less            reduce using rule 87 (unary -> postfix .)
    Greater         reduce using rule 87 (unary -> postfix .)
    LessEqual       reduce using rule 87 (unary -> postfix .)
    GreaterEqual    reduce using rule 87 (unary -> postfix .)
    NotEqual        reduce using rule 87 (unary -> postfix .)
    Equal           reduce using rule 87 (unary -> postfix .)
    BitAnd          reduce using rule 87 (unary -> postfix .)
    Xor             reduce using rule 87 (unary -> postfix .)
    BitOr           reduce using rule 87 (unary -> postfix .)
    And             reduce using rule 87 (unary -> postfix .)
    Question        reduce using rule 87 (unary -> postfix .)
    Or              reduce using rule 87 (unary -> postfix .)
    Semi            reduce using rule 87 (unary -> postfix .)
    RParen          reduce using rule 87 (unary -> postfix .)
    Comma           reduce using rule 87 (unary -> postfix .)
    Colon           reduce using rule 87 (unary -> postfix .)
    RMidBrace       reduce using rule 87 (unary -> postfix .)


state 22

    (77) conditional -> logical_or .
    (113) conditional -> logical_or . Question expression Colon conditional
    (97) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 77 (conditional -> logical_or .)
    RParen          reduce using rule 77 (conditional -> logical_or .)
    Comma           reduce using rule 77 (conditional -> logical_or .)
    Colon           reduce using rule 77 (conditional -> logical_or .)
    RMidBrace       reduce using rule 77 (conditional -> logical_or .)
    Question        shift and go to state 49
    Or              shift and go to state 50


state 23

    (88) postfix -> primary .
    (92) postfix_array -> primary .

    Assign          reduce using rule 88 (postfix -> primary .)
    Mul             reduce using rule 88 (postfix -> primary .)
    Div             reduce using rule 88 (postfix -> primary .)
    Mod             reduce using rule 88 (postfix -> primary .)
    Plus            reduce using rule 88 (postfix -> primary .)
    Minus           reduce using rule 88 (postfix -> primary .)
    Less            reduce using rule 88 (postfix -> primary .)
    Greater         reduce using rule 88 (postfix -> primary .)
    LessEqual       reduce using rule 88 (postfix -> primary .)
    GreaterEqual    reduce using rule 88 (postfix -> primary .)
    NotEqual        reduce using rule 88 (postfix -> primary .)
    Equal           reduce using rule 88 (postfix -> primary .)
    BitAnd          reduce using rule 88 (postfix -> primary .)
    Xor             reduce using rule 88 (postfix -> primary .)
    BitOr           reduce using rule 88 (postfix -> primary .)
    And             reduce using rule 88 (postfix -> primary .)
    Question        reduce using rule 88 (postfix -> primary .)
    Or              reduce using rule 88 (postfix -> primary .)
    Semi            reduce using rule 88 (postfix -> primary .)
    RParen          reduce using rule 88 (postfix -> primary .)
    Comma           reduce using rule 88 (postfix -> primary .)
    Colon           reduce using rule 88 (postfix -> primary .)
    RMidBrace       reduce using rule 88 (postfix -> primary .)
    LMidBrace       reduce using rule 92 (postfix_array -> primary .)


state 24

    (116) primary -> LParen . expression RParen
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 51
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 25

    (90) postfix -> postfix_array . LMidBrace expression RMidBrace
    (91) postfix_array -> postfix_array . LMidBrace expression RMidBrace

    LMidBrace       shift and go to state 52


state 26

    (78) logical_or -> logical_and .
    (98) logical_and -> logical_and . And bit_or

    Question        reduce using rule 78 (logical_or -> logical_and .)
    Or              reduce using rule 78 (logical_or -> logical_and .)
    Semi            reduce using rule 78 (logical_or -> logical_and .)
    RParen          reduce using rule 78 (logical_or -> logical_and .)
    Comma           reduce using rule 78 (logical_or -> logical_and .)
    Colon           reduce using rule 78 (logical_or -> logical_and .)
    RMidBrace       reduce using rule 78 (logical_or -> logical_and .)
    And             shift and go to state 53


state 27

    (114) primary -> Integer .

    Assign          reduce using rule 114 (primary -> Integer .)
    Mul             reduce using rule 114 (primary -> Integer .)
    Div             reduce using rule 114 (primary -> Integer .)
    Mod             reduce using rule 114 (primary -> Integer .)
    Plus            reduce using rule 114 (primary -> Integer .)
    Minus           reduce using rule 114 (primary -> Integer .)
    Less            reduce using rule 114 (primary -> Integer .)
    Greater         reduce using rule 114 (primary -> Integer .)
    LessEqual       reduce using rule 114 (primary -> Integer .)
    GreaterEqual    reduce using rule 114 (primary -> Integer .)
    NotEqual        reduce using rule 114 (primary -> Integer .)
    Equal           reduce using rule 114 (primary -> Integer .)
    BitAnd          reduce using rule 114 (primary -> Integer .)
    Xor             reduce using rule 114 (primary -> Integer .)
    BitOr           reduce using rule 114 (primary -> Integer .)
    And             reduce using rule 114 (primary -> Integer .)
    Question        reduce using rule 114 (primary -> Integer .)
    Or              reduce using rule 114 (primary -> Integer .)
    Semi            reduce using rule 114 (primary -> Integer .)
    LMidBrace       reduce using rule 114 (primary -> Integer .)
    RParen          reduce using rule 114 (primary -> Integer .)
    Comma           reduce using rule 114 (primary -> Integer .)
    Colon           reduce using rule 114 (primary -> Integer .)
    RMidBrace       reduce using rule 114 (primary -> Integer .)


state 28

    (79) logical_and -> bit_or .
    (99) bit_or -> bit_or . BitOr xor

    And             reduce using rule 79 (logical_and -> bit_or .)
    Question        reduce using rule 79 (logical_and -> bit_or .)
    Or              reduce using rule 79 (logical_and -> bit_or .)
    Semi            reduce using rule 79 (logical_and -> bit_or .)
    RParen          reduce using rule 79 (logical_and -> bit_or .)
    Comma           reduce using rule 79 (logical_and -> bit_or .)
    Colon           reduce using rule 79 (logical_and -> bit_or .)
    RMidBrace       reduce using rule 79 (logical_and -> bit_or .)
    BitOr           shift and go to state 54


state 29

    (80) bit_or -> xor .
    (100) xor -> xor . Xor bit_and

    BitOr           reduce using rule 80 (bit_or -> xor .)
    And             reduce using rule 80 (bit_or -> xor .)
    Question        reduce using rule 80 (bit_or -> xor .)
    Or              reduce using rule 80 (bit_or -> xor .)
    Semi            reduce using rule 80 (bit_or -> xor .)
    RParen          reduce using rule 80 (bit_or -> xor .)
    Comma           reduce using rule 80 (bit_or -> xor .)
    Colon           reduce using rule 80 (bit_or -> xor .)
    RMidBrace       reduce using rule 80 (bit_or -> xor .)
    Xor             shift and go to state 55


state 30

    (81) xor -> bit_and .
    (101) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 81 (xor -> bit_and .)
    BitOr           reduce using rule 81 (xor -> bit_and .)
    And             reduce using rule 81 (xor -> bit_and .)
    Question        reduce using rule 81 (xor -> bit_and .)
    Or              reduce using rule 81 (xor -> bit_and .)
    Semi            reduce using rule 81 (xor -> bit_and .)
    RParen          reduce using rule 81 (xor -> bit_and .)
    Comma           reduce using rule 81 (xor -> bit_and .)
    Colon           reduce using rule 81 (xor -> bit_and .)
    RMidBrace       reduce using rule 81 (xor -> bit_and .)
    BitAnd          shift and go to state 56


state 31

    (82) bit_and -> equality .
    (102) equality -> equality . NotEqual relational
    (103) equality -> equality . Equal relational

    BitAnd          reduce using rule 82 (bit_and -> equality .)
    Xor             reduce using rule 82 (bit_and -> equality .)
    BitOr           reduce using rule 82 (bit_and -> equality .)
    And             reduce using rule 82 (bit_and -> equality .)
    Question        reduce using rule 82 (bit_and -> equality .)
    Or              reduce using rule 82 (bit_and -> equality .)
    Semi            reduce using rule 82 (bit_and -> equality .)
    RParen          reduce using rule 82 (bit_and -> equality .)
    Comma           reduce using rule 82 (bit_and -> equality .)
    Colon           reduce using rule 82 (bit_and -> equality .)
    RMidBrace       reduce using rule 82 (bit_and -> equality .)
    NotEqual        shift and go to state 57
    Equal           shift and go to state 58


state 32

    (83) equality -> relational .
    (104) relational -> relational . Less additive
    (105) relational -> relational . Greater additive
    (106) relational -> relational . LessEqual additive
    (107) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 83 (equality -> relational .)
    Equal           reduce using rule 83 (equality -> relational .)
    BitAnd          reduce using rule 83 (equality -> relational .)
    Xor             reduce using rule 83 (equality -> relational .)
    BitOr           reduce using rule 83 (equality -> relational .)
    And             reduce using rule 83 (equality -> relational .)
    Question        reduce using rule 83 (equality -> relational .)
    Or              reduce using rule 83 (equality -> relational .)
    Semi            reduce using rule 83 (equality -> relational .)
    RParen          reduce using rule 83 (equality -> relational .)
    Comma           reduce using rule 83 (equality -> relational .)
    Colon           reduce using rule 83 (equality -> relational .)
    RMidBrace       reduce using rule 83 (equality -> relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 33

    (84) relational -> additive .
    (108) additive -> additive . Plus multiplicative
    (109) additive -> additive . Minus multiplicative

    Less            reduce using rule 84 (relational -> additive .)
    Greater         reduce using rule 84 (relational -> additive .)
    LessEqual       reduce using rule 84 (relational -> additive .)
    GreaterEqual    reduce using rule 84 (relational -> additive .)
    NotEqual        reduce using rule 84 (relational -> additive .)
    Equal           reduce using rule 84 (relational -> additive .)
    BitAnd          reduce using rule 84 (relational -> additive .)
    Xor             reduce using rule 84 (relational -> additive .)
    BitOr           reduce using rule 84 (relational -> additive .)
    And             reduce using rule 84 (relational -> additive .)
    Question        reduce using rule 84 (relational -> additive .)
    Or              reduce using rule 84 (relational -> additive .)
    Semi            reduce using rule 84 (relational -> additive .)
    RParen          reduce using rule 84 (relational -> additive .)
    Comma           reduce using rule 84 (relational -> additive .)
    Colon           reduce using rule 84 (relational -> additive .)
    RMidBrace       reduce using rule 84 (relational -> additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 34

    (85) additive -> multiplicative .
    (110) multiplicative -> multiplicative . Mul unary
    (111) multiplicative -> multiplicative . Div unary
    (112) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 85 (additive -> multiplicative .)
    Minus           reduce using rule 85 (additive -> multiplicative .)
    Less            reduce using rule 85 (additive -> multiplicative .)
    Greater         reduce using rule 85 (additive -> multiplicative .)
    LessEqual       reduce using rule 85 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 85 (additive -> multiplicative .)
    NotEqual        reduce using rule 85 (additive -> multiplicative .)
    Equal           reduce using rule 85 (additive -> multiplicative .)
    BitAnd          reduce using rule 85 (additive -> multiplicative .)
    Xor             reduce using rule 85 (additive -> multiplicative .)
    BitOr           reduce using rule 85 (additive -> multiplicative .)
    And             reduce using rule 85 (additive -> multiplicative .)
    Question        reduce using rule 85 (additive -> multiplicative .)
    Or              reduce using rule 85 (additive -> multiplicative .)
    Semi            reduce using rule 85 (additive -> multiplicative .)
    RParen          reduce using rule 85 (additive -> multiplicative .)
    Comma           reduce using rule 85 (additive -> multiplicative .)
    Colon           reduce using rule 85 (additive -> multiplicative .)
    RMidBrace       reduce using rule 85 (additive -> multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 35

    (93) unary -> Minus . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 68
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 36

    (86) multiplicative -> unary .

    Mul             reduce using rule 86 (multiplicative -> unary .)
    Div             reduce using rule 86 (multiplicative -> unary .)
    Mod             reduce using rule 86 (multiplicative -> unary .)
    Plus            reduce using rule 86 (multiplicative -> unary .)
    Minus           reduce using rule 86 (multiplicative -> unary .)
    Less            reduce using rule 86 (multiplicative -> unary .)
    Greater         reduce using rule 86 (multiplicative -> unary .)
    LessEqual       reduce using rule 86 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 86 (multiplicative -> unary .)
    NotEqual        reduce using rule 86 (multiplicative -> unary .)
    Equal           reduce using rule 86 (multiplicative -> unary .)
    BitAnd          reduce using rule 86 (multiplicative -> unary .)
    Xor             reduce using rule 86 (multiplicative -> unary .)
    BitOr           reduce using rule 86 (multiplicative -> unary .)
    And             reduce using rule 86 (multiplicative -> unary .)
    Question        reduce using rule 86 (multiplicative -> unary .)
    Or              reduce using rule 86 (multiplicative -> unary .)
    Semi            reduce using rule 86 (multiplicative -> unary .)
    RParen          reduce using rule 86 (multiplicative -> unary .)
    Comma           reduce using rule 86 (multiplicative -> unary .)
    Colon           reduce using rule 86 (multiplicative -> unary .)
    RMidBrace       reduce using rule 86 (multiplicative -> unary .)


state 37

    (94) unary -> BitNot . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 70
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 38

    (95) unary -> Not . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 71
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 39

    (7) globaldeclaration -> type Identifier indexlist Semi .

    Int             reduce using rule 7 (globaldeclaration -> type Identifier indexlist Semi .)
    $end            reduce using rule 7 (globaldeclaration -> type Identifier indexlist Semi .)


state 40

    (8) globaldeclaration -> type Identifier indexlist Assign . LBrace set RBrace Semi

    LBrace          shift and go to state 72


state 41

    (73) indexlist -> indexlist LMidBrace . Integer RMidBrace

    Integer         shift and go to state 73


state 42

    (74) indexlist -> LMidBrace Integer . RMidBrace

    RMidBrace       shift and go to state 74


state 43

    (18) parameter -> type Identifier .
    (19) parameter -> type Identifier . indexlist
    (20) parameter -> type Identifier . LMidBrace RMidBrace
    (21) parameter -> type Identifier . LMidBrace RMidBrace indexlist
    (73) indexlist -> . indexlist LMidBrace Integer RMidBrace
    (74) indexlist -> . LMidBrace Integer RMidBrace

    RParen          reduce using rule 18 (parameter -> type Identifier .)
    Comma           reduce using rule 18 (parameter -> type Identifier .)
    LMidBrace       shift and go to state 76

    indexlist                      shift and go to state 75

state 44

    (13) function -> type Identifier LParen parameterlist RParen . Semi
    (14) function -> type Identifier LParen parameterlist RParen . LBrace block RBrace

    Semi            shift and go to state 77
    LBrace          shift and go to state 78


state 45

    (17) parameterlist -> parameterlist Comma . parameter
    (18) parameter -> . type Identifier
    (19) parameter -> . type Identifier indexlist
    (20) parameter -> . type Identifier LMidBrace RMidBrace
    (21) parameter -> . type Identifier LMidBrace RMidBrace indexlist
    (12) type -> . Int

    Int             shift and go to state 6

    parameter                      shift and go to state 79
    type                           shift and go to state 13

state 46

    (89) postfix -> Identifier LParen . expressionlist RParen
    (22) expressionlist -> . empty
    (23) expressionlist -> . expression
    (24) expressionlist -> . expressionlist Comma expression
    (1) empty -> .
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expressionlist                 shift and go to state 80
    empty                          shift and go to state 81
    expression                     shift and go to state 82
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 47

    (6) globaldeclaration -> type Identifier Assign expression Semi .

    Int             reduce using rule 6 (globaldeclaration -> type Identifier Assign expression Semi .)
    $end            reduce using rule 6 (globaldeclaration -> type Identifier Assign expression Semi .)


state 48

    (96) assignment -> postfix Assign . expression
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    postfix                        shift and go to state 21
    expression                     shift and go to state 83
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 49

    (113) conditional -> logical_or Question . expression Colon conditional
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    logical_or                     shift and go to state 22
    expression                     shift and go to state 84
    conditional                    shift and go to state 20
    assignment                     shift and go to state 19
    postfix                        shift and go to state 21
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 50

    (97) logical_or -> logical_or Or . logical_and
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    logical_and                    shift and go to state 85
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 51

    (116) primary -> LParen expression . RParen

    RParen          shift and go to state 86


state 52

    (90) postfix -> postfix_array LMidBrace . expression RMidBrace
    (91) postfix_array -> postfix_array LMidBrace . expression RMidBrace
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    postfix_array                  shift and go to state 25
    expression                     shift and go to state 87
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 53

    (98) logical_and -> logical_and And . bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    bit_or                         shift and go to state 88
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 54

    (99) bit_or -> bit_or BitOr . xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    xor                            shift and go to state 89
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 55

    (100) xor -> xor Xor . bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    bit_and                        shift and go to state 90
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 56

    (101) bit_and -> bit_and BitAnd . equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    equality                       shift and go to state 91
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 57

    (102) equality -> equality NotEqual . relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    relational                     shift and go to state 92
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 58

    (103) equality -> equality Equal . relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    relational                     shift and go to state 93
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 59

    (104) relational -> relational Less . additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    additive                       shift and go to state 94
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 60

    (105) relational -> relational Greater . additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    additive                       shift and go to state 95
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 61

    (106) relational -> relational LessEqual . additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    additive                       shift and go to state 96
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 62

    (107) relational -> relational GreaterEqual . additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    additive                       shift and go to state 97
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 63

    (108) additive -> additive Plus . multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    multiplicative                 shift and go to state 98
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 64

    (109) additive -> additive Minus . multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    multiplicative                 shift and go to state 99
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 65

    (110) multiplicative -> multiplicative Mul . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 100
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 66

    (111) multiplicative -> multiplicative Div . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 101
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 67

    (112) multiplicative -> multiplicative Mod . unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    unary                          shift and go to state 102
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 68

    (93) unary -> Minus unary .

    Mul             reduce using rule 93 (unary -> Minus unary .)
    Div             reduce using rule 93 (unary -> Minus unary .)
    Mod             reduce using rule 93 (unary -> Minus unary .)
    Plus            reduce using rule 93 (unary -> Minus unary .)
    Minus           reduce using rule 93 (unary -> Minus unary .)
    Less            reduce using rule 93 (unary -> Minus unary .)
    Greater         reduce using rule 93 (unary -> Minus unary .)
    LessEqual       reduce using rule 93 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 93 (unary -> Minus unary .)
    NotEqual        reduce using rule 93 (unary -> Minus unary .)
    Equal           reduce using rule 93 (unary -> Minus unary .)
    BitAnd          reduce using rule 93 (unary -> Minus unary .)
    Xor             reduce using rule 93 (unary -> Minus unary .)
    BitOr           reduce using rule 93 (unary -> Minus unary .)
    And             reduce using rule 93 (unary -> Minus unary .)
    Question        reduce using rule 93 (unary -> Minus unary .)
    Or              reduce using rule 93 (unary -> Minus unary .)
    Semi            reduce using rule 93 (unary -> Minus unary .)
    RParen          reduce using rule 93 (unary -> Minus unary .)
    Comma           reduce using rule 93 (unary -> Minus unary .)
    Colon           reduce using rule 93 (unary -> Minus unary .)
    RMidBrace       reduce using rule 93 (unary -> Minus unary .)


state 69

    (87) unary -> postfix .

    Mul             reduce using rule 87 (unary -> postfix .)
    Div             reduce using rule 87 (unary -> postfix .)
    Mod             reduce using rule 87 (unary -> postfix .)
    Plus            reduce using rule 87 (unary -> postfix .)
    Minus           reduce using rule 87 (unary -> postfix .)
    Less            reduce using rule 87 (unary -> postfix .)
    Greater         reduce using rule 87 (unary -> postfix .)
    LessEqual       reduce using rule 87 (unary -> postfix .)
    GreaterEqual    reduce using rule 87 (unary -> postfix .)
    NotEqual        reduce using rule 87 (unary -> postfix .)
    Equal           reduce using rule 87 (unary -> postfix .)
    BitAnd          reduce using rule 87 (unary -> postfix .)
    Xor             reduce using rule 87 (unary -> postfix .)
    BitOr           reduce using rule 87 (unary -> postfix .)
    And             reduce using rule 87 (unary -> postfix .)
    Question        reduce using rule 87 (unary -> postfix .)
    Or              reduce using rule 87 (unary -> postfix .)
    Semi            reduce using rule 87 (unary -> postfix .)
    RParen          reduce using rule 87 (unary -> postfix .)
    Comma           reduce using rule 87 (unary -> postfix .)
    Colon           reduce using rule 87 (unary -> postfix .)
    RMidBrace       reduce using rule 87 (unary -> postfix .)


state 70

    (94) unary -> BitNot unary .

    Mul             reduce using rule 94 (unary -> BitNot unary .)
    Div             reduce using rule 94 (unary -> BitNot unary .)
    Mod             reduce using rule 94 (unary -> BitNot unary .)
    Plus            reduce using rule 94 (unary -> BitNot unary .)
    Minus           reduce using rule 94 (unary -> BitNot unary .)
    Less            reduce using rule 94 (unary -> BitNot unary .)
    Greater         reduce using rule 94 (unary -> BitNot unary .)
    LessEqual       reduce using rule 94 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 94 (unary -> BitNot unary .)
    NotEqual        reduce using rule 94 (unary -> BitNot unary .)
    Equal           reduce using rule 94 (unary -> BitNot unary .)
    BitAnd          reduce using rule 94 (unary -> BitNot unary .)
    Xor             reduce using rule 94 (unary -> BitNot unary .)
    BitOr           reduce using rule 94 (unary -> BitNot unary .)
    And             reduce using rule 94 (unary -> BitNot unary .)
    Question        reduce using rule 94 (unary -> BitNot unary .)
    Or              reduce using rule 94 (unary -> BitNot unary .)
    Semi            reduce using rule 94 (unary -> BitNot unary .)
    RParen          reduce using rule 94 (unary -> BitNot unary .)
    Comma           reduce using rule 94 (unary -> BitNot unary .)
    Colon           reduce using rule 94 (unary -> BitNot unary .)
    RMidBrace       reduce using rule 94 (unary -> BitNot unary .)


state 71

    (95) unary -> Not unary .

    Mul             reduce using rule 95 (unary -> Not unary .)
    Div             reduce using rule 95 (unary -> Not unary .)
    Mod             reduce using rule 95 (unary -> Not unary .)
    Plus            reduce using rule 95 (unary -> Not unary .)
    Minus           reduce using rule 95 (unary -> Not unary .)
    Less            reduce using rule 95 (unary -> Not unary .)
    Greater         reduce using rule 95 (unary -> Not unary .)
    LessEqual       reduce using rule 95 (unary -> Not unary .)
    GreaterEqual    reduce using rule 95 (unary -> Not unary .)
    NotEqual        reduce using rule 95 (unary -> Not unary .)
    Equal           reduce using rule 95 (unary -> Not unary .)
    BitAnd          reduce using rule 95 (unary -> Not unary .)
    Xor             reduce using rule 95 (unary -> Not unary .)
    BitOr           reduce using rule 95 (unary -> Not unary .)
    And             reduce using rule 95 (unary -> Not unary .)
    Question        reduce using rule 95 (unary -> Not unary .)
    Or              reduce using rule 95 (unary -> Not unary .)
    Semi            reduce using rule 95 (unary -> Not unary .)
    RParen          reduce using rule 95 (unary -> Not unary .)
    Comma           reduce using rule 95 (unary -> Not unary .)
    Colon           reduce using rule 95 (unary -> Not unary .)
    RMidBrace       reduce using rule 95 (unary -> Not unary .)


state 72

    (8) globaldeclaration -> type Identifier indexlist Assign LBrace . set RBrace Semi
    (9) set -> . empty
    (10) set -> . Integer
    (11) set -> . set Comma Integer
    (1) empty -> .

    Integer         shift and go to state 105
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    set                            shift and go to state 103
    empty                          shift and go to state 104

state 73

    (73) indexlist -> indexlist LMidBrace Integer . RMidBrace

    RMidBrace       shift and go to state 106


state 74

    (74) indexlist -> LMidBrace Integer RMidBrace .

    Semi            reduce using rule 74 (indexlist -> LMidBrace Integer RMidBrace .)
    Assign          reduce using rule 74 (indexlist -> LMidBrace Integer RMidBrace .)
    LMidBrace       reduce using rule 74 (indexlist -> LMidBrace Integer RMidBrace .)
    RParen          reduce using rule 74 (indexlist -> LMidBrace Integer RMidBrace .)
    Comma           reduce using rule 74 (indexlist -> LMidBrace Integer RMidBrace .)


state 75

    (19) parameter -> type Identifier indexlist .
    (73) indexlist -> indexlist . LMidBrace Integer RMidBrace

    RParen          reduce using rule 19 (parameter -> type Identifier indexlist .)
    Comma           reduce using rule 19 (parameter -> type Identifier indexlist .)
    LMidBrace       shift and go to state 41


state 76

    (20) parameter -> type Identifier LMidBrace . RMidBrace
    (21) parameter -> type Identifier LMidBrace . RMidBrace indexlist
    (74) indexlist -> LMidBrace . Integer RMidBrace

    RMidBrace       shift and go to state 107
    Integer         shift and go to state 42


state 77

    (13) function -> type Identifier LParen parameterlist RParen Semi .

    Int             reduce using rule 13 (function -> type Identifier LParen parameterlist RParen Semi .)
    $end            reduce using rule 13 (function -> type Identifier LParen parameterlist RParen Semi .)


state 78

    (14) function -> type Identifier LParen parameterlist RParen LBrace . block RBrace
    (25) block -> . block block_item
    (26) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 108
    empty                          shift and go to state 109

state 79

    (17) parameterlist -> parameterlist Comma parameter .

    RParen          reduce using rule 17 (parameterlist -> parameterlist Comma parameter .)
    Comma           reduce using rule 17 (parameterlist -> parameterlist Comma parameter .)


state 80

    (89) postfix -> Identifier LParen expressionlist . RParen
    (24) expressionlist -> expressionlist . Comma expression

    RParen          shift and go to state 110
    Comma           shift and go to state 111


state 81

    (22) expressionlist -> empty .

    RParen          reduce using rule 22 (expressionlist -> empty .)
    Comma           reduce using rule 22 (expressionlist -> empty .)


state 82

    (23) expressionlist -> expression .

    RParen          reduce using rule 23 (expressionlist -> expression .)
    Comma           reduce using rule 23 (expressionlist -> expression .)


state 83

    (96) assignment -> postfix Assign expression .

    Semi            reduce using rule 96 (assignment -> postfix Assign expression .)
    RParen          reduce using rule 96 (assignment -> postfix Assign expression .)
    Comma           reduce using rule 96 (assignment -> postfix Assign expression .)
    Colon           reduce using rule 96 (assignment -> postfix Assign expression .)
    RMidBrace       reduce using rule 96 (assignment -> postfix Assign expression .)


state 84

    (113) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 112


state 85

    (97) logical_or -> logical_or Or logical_and .
    (98) logical_and -> logical_and . And bit_or

    Question        reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    RMidBrace       reduce using rule 97 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 53


state 86

    (116) primary -> LParen expression RParen .

    Assign          reduce using rule 116 (primary -> LParen expression RParen .)
    Mul             reduce using rule 116 (primary -> LParen expression RParen .)
    Div             reduce using rule 116 (primary -> LParen expression RParen .)
    Mod             reduce using rule 116 (primary -> LParen expression RParen .)
    Plus            reduce using rule 116 (primary -> LParen expression RParen .)
    Minus           reduce using rule 116 (primary -> LParen expression RParen .)
    Less            reduce using rule 116 (primary -> LParen expression RParen .)
    Greater         reduce using rule 116 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 116 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 116 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 116 (primary -> LParen expression RParen .)
    Equal           reduce using rule 116 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 116 (primary -> LParen expression RParen .)
    Xor             reduce using rule 116 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 116 (primary -> LParen expression RParen .)
    And             reduce using rule 116 (primary -> LParen expression RParen .)
    Question        reduce using rule 116 (primary -> LParen expression RParen .)
    Or              reduce using rule 116 (primary -> LParen expression RParen .)
    Semi            reduce using rule 116 (primary -> LParen expression RParen .)
    LMidBrace       reduce using rule 116 (primary -> LParen expression RParen .)
    RParen          reduce using rule 116 (primary -> LParen expression RParen .)
    Comma           reduce using rule 116 (primary -> LParen expression RParen .)
    Colon           reduce using rule 116 (primary -> LParen expression RParen .)
    RMidBrace       reduce using rule 116 (primary -> LParen expression RParen .)


state 87

    (90) postfix -> postfix_array LMidBrace expression . RMidBrace
    (91) postfix_array -> postfix_array LMidBrace expression . RMidBrace

    RMidBrace       shift and go to state 113


state 88

    (98) logical_and -> logical_and And bit_or .
    (99) bit_or -> bit_or . BitOr xor

    And             reduce using rule 98 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 98 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 98 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 98 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 98 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 98 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 98 (logical_and -> logical_and And bit_or .)
    RMidBrace       reduce using rule 98 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 54


state 89

    (99) bit_or -> bit_or BitOr xor .
    (100) xor -> xor . Xor bit_and

    BitOr           reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    RMidBrace       reduce using rule 99 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 55


state 90

    (100) xor -> xor Xor bit_and .
    (101) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 100 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 100 (xor -> xor Xor bit_and .)
    And             reduce using rule 100 (xor -> xor Xor bit_and .)
    Question        reduce using rule 100 (xor -> xor Xor bit_and .)
    Or              reduce using rule 100 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 100 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 100 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 100 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 100 (xor -> xor Xor bit_and .)
    RMidBrace       reduce using rule 100 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 56


state 91

    (101) bit_and -> bit_and BitAnd equality .
    (102) equality -> equality . NotEqual relational
    (103) equality -> equality . Equal relational

    BitAnd          reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    RMidBrace       reduce using rule 101 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 57
    Equal           shift and go to state 58


state 92

    (102) equality -> equality NotEqual relational .
    (104) relational -> relational . Less additive
    (105) relational -> relational . Greater additive
    (106) relational -> relational . LessEqual additive
    (107) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 102 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 102 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 102 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 102 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 102 (equality -> equality NotEqual relational .)
    And             reduce using rule 102 (equality -> equality NotEqual relational .)
    Question        reduce using rule 102 (equality -> equality NotEqual relational .)
    Or              reduce using rule 102 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 102 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 102 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 102 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 102 (equality -> equality NotEqual relational .)
    RMidBrace       reduce using rule 102 (equality -> equality NotEqual relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 93

    (103) equality -> equality Equal relational .
    (104) relational -> relational . Less additive
    (105) relational -> relational . Greater additive
    (106) relational -> relational . LessEqual additive
    (107) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 103 (equality -> equality Equal relational .)
    Equal           reduce using rule 103 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 103 (equality -> equality Equal relational .)
    Xor             reduce using rule 103 (equality -> equality Equal relational .)
    BitOr           reduce using rule 103 (equality -> equality Equal relational .)
    And             reduce using rule 103 (equality -> equality Equal relational .)
    Question        reduce using rule 103 (equality -> equality Equal relational .)
    Or              reduce using rule 103 (equality -> equality Equal relational .)
    Semi            reduce using rule 103 (equality -> equality Equal relational .)
    RParen          reduce using rule 103 (equality -> equality Equal relational .)
    Comma           reduce using rule 103 (equality -> equality Equal relational .)
    Colon           reduce using rule 103 (equality -> equality Equal relational .)
    RMidBrace       reduce using rule 103 (equality -> equality Equal relational .)
    Less            shift and go to state 59
    Greater         shift and go to state 60
    LessEqual       shift and go to state 61
    GreaterEqual    shift and go to state 62


state 94

    (104) relational -> relational Less additive .
    (108) additive -> additive . Plus multiplicative
    (109) additive -> additive . Minus multiplicative

    Less            reduce using rule 104 (relational -> relational Less additive .)
    Greater         reduce using rule 104 (relational -> relational Less additive .)
    LessEqual       reduce using rule 104 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 104 (relational -> relational Less additive .)
    NotEqual        reduce using rule 104 (relational -> relational Less additive .)
    Equal           reduce using rule 104 (relational -> relational Less additive .)
    BitAnd          reduce using rule 104 (relational -> relational Less additive .)
    Xor             reduce using rule 104 (relational -> relational Less additive .)
    BitOr           reduce using rule 104 (relational -> relational Less additive .)
    And             reduce using rule 104 (relational -> relational Less additive .)
    Question        reduce using rule 104 (relational -> relational Less additive .)
    Or              reduce using rule 104 (relational -> relational Less additive .)
    Semi            reduce using rule 104 (relational -> relational Less additive .)
    RParen          reduce using rule 104 (relational -> relational Less additive .)
    Comma           reduce using rule 104 (relational -> relational Less additive .)
    Colon           reduce using rule 104 (relational -> relational Less additive .)
    RMidBrace       reduce using rule 104 (relational -> relational Less additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 95

    (105) relational -> relational Greater additive .
    (108) additive -> additive . Plus multiplicative
    (109) additive -> additive . Minus multiplicative

    Less            reduce using rule 105 (relational -> relational Greater additive .)
    Greater         reduce using rule 105 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 105 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 105 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 105 (relational -> relational Greater additive .)
    Equal           reduce using rule 105 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 105 (relational -> relational Greater additive .)
    Xor             reduce using rule 105 (relational -> relational Greater additive .)
    BitOr           reduce using rule 105 (relational -> relational Greater additive .)
    And             reduce using rule 105 (relational -> relational Greater additive .)
    Question        reduce using rule 105 (relational -> relational Greater additive .)
    Or              reduce using rule 105 (relational -> relational Greater additive .)
    Semi            reduce using rule 105 (relational -> relational Greater additive .)
    RParen          reduce using rule 105 (relational -> relational Greater additive .)
    Comma           reduce using rule 105 (relational -> relational Greater additive .)
    Colon           reduce using rule 105 (relational -> relational Greater additive .)
    RMidBrace       reduce using rule 105 (relational -> relational Greater additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 96

    (106) relational -> relational LessEqual additive .
    (108) additive -> additive . Plus multiplicative
    (109) additive -> additive . Minus multiplicative

    Less            reduce using rule 106 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 106 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 106 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 106 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 106 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 106 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 106 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 106 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 106 (relational -> relational LessEqual additive .)
    And             reduce using rule 106 (relational -> relational LessEqual additive .)
    Question        reduce using rule 106 (relational -> relational LessEqual additive .)
    Or              reduce using rule 106 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 106 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 106 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 106 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 106 (relational -> relational LessEqual additive .)
    RMidBrace       reduce using rule 106 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 97

    (107) relational -> relational GreaterEqual additive .
    (108) additive -> additive . Plus multiplicative
    (109) additive -> additive . Minus multiplicative

    Less            reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 107 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 107 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 107 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 107 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 107 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 107 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 107 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 107 (relational -> relational GreaterEqual additive .)
    RMidBrace       reduce using rule 107 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 63
    Minus           shift and go to state 64


state 98

    (108) additive -> additive Plus multiplicative .
    (110) multiplicative -> multiplicative . Mul unary
    (111) multiplicative -> multiplicative . Div unary
    (112) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 108 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 108 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 108 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 108 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 108 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 108 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 108 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 108 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 108 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 108 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 108 (additive -> additive Plus multiplicative .)
    And             reduce using rule 108 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 108 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 108 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 108 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 108 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 108 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 108 (additive -> additive Plus multiplicative .)
    RMidBrace       reduce using rule 108 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 99

    (109) additive -> additive Minus multiplicative .
    (110) multiplicative -> multiplicative . Mul unary
    (111) multiplicative -> multiplicative . Div unary
    (112) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 109 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 109 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 109 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 109 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 109 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 109 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 109 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 109 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 109 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 109 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 109 (additive -> additive Minus multiplicative .)
    And             reduce using rule 109 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 109 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 109 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 109 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 109 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 109 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 109 (additive -> additive Minus multiplicative .)
    RMidBrace       reduce using rule 109 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 65
    Div             shift and go to state 66
    Mod             shift and go to state 67


state 100

    (110) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 110 (multiplicative -> multiplicative Mul unary .)
    RMidBrace       reduce using rule 110 (multiplicative -> multiplicative Mul unary .)


state 101

    (111) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 111 (multiplicative -> multiplicative Div unary .)
    RMidBrace       reduce using rule 111 (multiplicative -> multiplicative Div unary .)


state 102

    (112) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 112 (multiplicative -> multiplicative Mod unary .)
    RMidBrace       reduce using rule 112 (multiplicative -> multiplicative Mod unary .)


state 103

    (8) globaldeclaration -> type Identifier indexlist Assign LBrace set . RBrace Semi
    (11) set -> set . Comma Integer

    RBrace          shift and go to state 114
    Comma           shift and go to state 115


state 104

    (9) set -> empty .

    RBrace          reduce using rule 9 (set -> empty .)
    Comma           reduce using rule 9 (set -> empty .)


state 105

    (10) set -> Integer .

    RBrace          reduce using rule 10 (set -> Integer .)
    Comma           reduce using rule 10 (set -> Integer .)


state 106

    (73) indexlist -> indexlist LMidBrace Integer RMidBrace .

    Semi            reduce using rule 73 (indexlist -> indexlist LMidBrace Integer RMidBrace .)
    Assign          reduce using rule 73 (indexlist -> indexlist LMidBrace Integer RMidBrace .)
    LMidBrace       reduce using rule 73 (indexlist -> indexlist LMidBrace Integer RMidBrace .)
    RParen          reduce using rule 73 (indexlist -> indexlist LMidBrace Integer RMidBrace .)
    Comma           reduce using rule 73 (indexlist -> indexlist LMidBrace Integer RMidBrace .)


state 107

    (20) parameter -> type Identifier LMidBrace RMidBrace .
    (21) parameter -> type Identifier LMidBrace RMidBrace . indexlist
    (73) indexlist -> . indexlist LMidBrace Integer RMidBrace
    (74) indexlist -> . LMidBrace Integer RMidBrace

    RParen          reduce using rule 20 (parameter -> type Identifier LMidBrace RMidBrace .)
    Comma           reduce using rule 20 (parameter -> type Identifier LMidBrace RMidBrace .)
    LMidBrace       shift and go to state 12

    indexlist                      shift and go to state 116

state 108

    (14) function -> type Identifier LParen parameterlist RParen LBrace block . RBrace
    (25) block -> block . block_item
    (27) block_item -> . statement
    (28) block_item -> . declaration Semi
    (29) statement -> . statement_matched
    (30) statement -> . statement_unmatched
    (69) declaration -> . type Identifier
    (70) declaration -> . type Identifier Assign expression
    (71) declaration -> . type Identifier indexlist
    (72) declaration -> . type Identifier indexlist Assign LBrace set RBrace
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (12) type -> . Int
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RBrace          shift and go to state 119
    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    type                           shift and go to state 117
    block_item                     shift and go to state 120
    statement                      shift and go to state 121
    declaration                    shift and go to state 122
    statement_matched              shift and go to state 123
    statement_unmatched            shift and go to state 124
    expression                     shift and go to state 125
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 109

    (26) block -> empty .

    RBrace          reduce using rule 26 (block -> empty .)
    If              reduce using rule 26 (block -> empty .)
    While           reduce using rule 26 (block -> empty .)
    For             reduce using rule 26 (block -> empty .)
    Do              reduce using rule 26 (block -> empty .)
    Return          reduce using rule 26 (block -> empty .)
    LBrace          reduce using rule 26 (block -> empty .)
    Break           reduce using rule 26 (block -> empty .)
    Continue        reduce using rule 26 (block -> empty .)
    Int             reduce using rule 26 (block -> empty .)
    Identifier      reduce using rule 26 (block -> empty .)
    Integer         reduce using rule 26 (block -> empty .)
    LParen          reduce using rule 26 (block -> empty .)
    Minus           reduce using rule 26 (block -> empty .)
    BitNot          reduce using rule 26 (block -> empty .)
    Not             reduce using rule 26 (block -> empty .)
    Semi            reduce using rule 26 (block -> empty .)


state 110

    (89) postfix -> Identifier LParen expressionlist RParen .

    Assign          reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Mul             reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Div             reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Mod             reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Plus            reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Minus           reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Less            reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Greater         reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    LessEqual       reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    GreaterEqual    reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    NotEqual        reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Equal           reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    BitAnd          reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Xor             reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    BitOr           reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    And             reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Question        reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Or              reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Semi            reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    RParen          reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Comma           reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    Colon           reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)
    RMidBrace       reduce using rule 89 (postfix -> Identifier LParen expressionlist RParen .)


state 111

    (24) expressionlist -> expressionlist Comma . expression
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 135
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 112

    (113) conditional -> logical_or Question expression Colon . conditional
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary

    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24

    logical_or                     shift and go to state 22
    conditional                    shift and go to state 136
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36
    postfix                        shift and go to state 69
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25

state 113

    (90) postfix -> postfix_array LMidBrace expression RMidBrace .
    (91) postfix_array -> postfix_array LMidBrace expression RMidBrace .

    Assign          reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Mul             reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Div             reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Mod             reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Plus            reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Minus           reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Less            reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Greater         reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    LessEqual       reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    GreaterEqual    reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    NotEqual        reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Equal           reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    BitAnd          reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Xor             reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    BitOr           reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    And             reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Question        reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Or              reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Semi            reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    RParen          reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Comma           reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    Colon           reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    RMidBrace       reduce using rule 90 (postfix -> postfix_array LMidBrace expression RMidBrace .)
    LMidBrace       reduce using rule 91 (postfix_array -> postfix_array LMidBrace expression RMidBrace .)


state 114

    (8) globaldeclaration -> type Identifier indexlist Assign LBrace set RBrace . Semi

    Semi            shift and go to state 137


state 115

    (11) set -> set Comma . Integer

    Integer         shift and go to state 138


state 116

    (21) parameter -> type Identifier LMidBrace RMidBrace indexlist .
    (73) indexlist -> indexlist . LMidBrace Integer RMidBrace

    RParen          reduce using rule 21 (parameter -> type Identifier LMidBrace RMidBrace indexlist .)
    Comma           reduce using rule 21 (parameter -> type Identifier LMidBrace RMidBrace indexlist .)
    LMidBrace       shift and go to state 41


state 117

    (69) declaration -> type . Identifier
    (70) declaration -> type . Identifier Assign expression
    (71) declaration -> type . Identifier indexlist
    (72) declaration -> type . Identifier indexlist Assign LBrace set RBrace

    Identifier      shift and go to state 139


state 118

    (64) statement_matched -> LBrace . block RBrace
    (25) block -> . block block_item
    (26) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 140
    empty                          shift and go to state 109

state 119

    (14) function -> type Identifier LParen parameterlist RParen LBrace block RBrace .

    Int             reduce using rule 14 (function -> type Identifier LParen parameterlist RParen LBrace block RBrace .)
    $end            reduce using rule 14 (function -> type Identifier LParen parameterlist RParen LBrace block RBrace .)


state 120

    (25) block -> block block_item .

    RBrace          reduce using rule 25 (block -> block block_item .)
    If              reduce using rule 25 (block -> block block_item .)
    While           reduce using rule 25 (block -> block block_item .)
    For             reduce using rule 25 (block -> block block_item .)
    Do              reduce using rule 25 (block -> block block_item .)
    Return          reduce using rule 25 (block -> block block_item .)
    LBrace          reduce using rule 25 (block -> block block_item .)
    Break           reduce using rule 25 (block -> block block_item .)
    Continue        reduce using rule 25 (block -> block block_item .)
    Int             reduce using rule 25 (block -> block block_item .)
    Identifier      reduce using rule 25 (block -> block block_item .)
    Integer         reduce using rule 25 (block -> block block_item .)
    LParen          reduce using rule 25 (block -> block block_item .)
    Minus           reduce using rule 25 (block -> block block_item .)
    BitNot          reduce using rule 25 (block -> block block_item .)
    Not             reduce using rule 25 (block -> block block_item .)
    Semi            reduce using rule 25 (block -> block block_item .)


state 121

    (27) block_item -> statement .

    RBrace          reduce using rule 27 (block_item -> statement .)
    If              reduce using rule 27 (block_item -> statement .)
    While           reduce using rule 27 (block_item -> statement .)
    For             reduce using rule 27 (block_item -> statement .)
    Do              reduce using rule 27 (block_item -> statement .)
    Return          reduce using rule 27 (block_item -> statement .)
    LBrace          reduce using rule 27 (block_item -> statement .)
    Break           reduce using rule 27 (block_item -> statement .)
    Continue        reduce using rule 27 (block_item -> statement .)
    Int             reduce using rule 27 (block_item -> statement .)
    Identifier      reduce using rule 27 (block_item -> statement .)
    Integer         reduce using rule 27 (block_item -> statement .)
    LParen          reduce using rule 27 (block_item -> statement .)
    Minus           reduce using rule 27 (block_item -> statement .)
    BitNot          reduce using rule 27 (block_item -> statement .)
    Not             reduce using rule 27 (block_item -> statement .)
    Semi            reduce using rule 27 (block_item -> statement .)


state 122

    (28) block_item -> declaration . Semi

    Semi            shift and go to state 141


state 123

    (29) statement -> statement_matched .

    RBrace          reduce using rule 29 (statement -> statement_matched .)
    If              reduce using rule 29 (statement -> statement_matched .)
    While           reduce using rule 29 (statement -> statement_matched .)
    For             reduce using rule 29 (statement -> statement_matched .)
    Do              reduce using rule 29 (statement -> statement_matched .)
    Return          reduce using rule 29 (statement -> statement_matched .)
    LBrace          reduce using rule 29 (statement -> statement_matched .)
    Break           reduce using rule 29 (statement -> statement_matched .)
    Continue        reduce using rule 29 (statement -> statement_matched .)
    Int             reduce using rule 29 (statement -> statement_matched .)
    Identifier      reduce using rule 29 (statement -> statement_matched .)
    Integer         reduce using rule 29 (statement -> statement_matched .)
    LParen          reduce using rule 29 (statement -> statement_matched .)
    Minus           reduce using rule 29 (statement -> statement_matched .)
    BitNot          reduce using rule 29 (statement -> statement_matched .)
    Not             reduce using rule 29 (statement -> statement_matched .)
    Semi            reduce using rule 29 (statement -> statement_matched .)


state 124

    (30) statement -> statement_unmatched .

    RBrace          reduce using rule 30 (statement -> statement_unmatched .)
    If              reduce using rule 30 (statement -> statement_unmatched .)
    While           reduce using rule 30 (statement -> statement_unmatched .)
    For             reduce using rule 30 (statement -> statement_unmatched .)
    Do              reduce using rule 30 (statement -> statement_unmatched .)
    Return          reduce using rule 30 (statement -> statement_unmatched .)
    LBrace          reduce using rule 30 (statement -> statement_unmatched .)
    Break           reduce using rule 30 (statement -> statement_unmatched .)
    Continue        reduce using rule 30 (statement -> statement_unmatched .)
    Int             reduce using rule 30 (statement -> statement_unmatched .)
    Identifier      reduce using rule 30 (statement -> statement_unmatched .)
    Integer         reduce using rule 30 (statement -> statement_unmatched .)
    LParen          reduce using rule 30 (statement -> statement_unmatched .)
    Minus           reduce using rule 30 (statement -> statement_unmatched .)
    BitNot          reduce using rule 30 (statement -> statement_unmatched .)
    Not             reduce using rule 30 (statement -> statement_unmatched .)
    Semi            reduce using rule 30 (statement -> statement_unmatched .)


state 125

    (67) opt_expression -> expression .

    Semi            reduce using rule 67 (opt_expression -> expression .)


state 126

    (31) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (32) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 142


state 127

    (34) statement_matched -> While . LParen expression RParen statement_matched
    (35) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 143


state 128

    (36) statement_matched -> For . LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> For . LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> For . LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> For . LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> For . LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> For . LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> For . LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> For . LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> For . LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> For . LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> For . LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> For . LParen Semi Semi RParen statement_matched
    (38) statement_unmatched -> For . LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> For . LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> For . LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> For . LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> For . LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> For . LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> For . LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> For . LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> For . LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> For . LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> For . LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> For . LParen Semi Semi RParen statement_unmatched

    LParen          shift and go to state 144


state 129

    (60) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (61) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    statement_matched              shift and go to state 145
    expression                     shift and go to state 125
    statement_unmatched            shift and go to state 146
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 130

    (62) statement_matched -> Return . expression Semi
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 147
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 131

    (63) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 148


state 132

    (65) statement_matched -> Break . Semi

    Semi            shift and go to state 149


state 133

    (66) statement_matched -> Continue . Semi

    Semi            shift and go to state 150


state 134

    (68) opt_expression -> empty .

    Semi            reduce using rule 68 (opt_expression -> empty .)


state 135

    (24) expressionlist -> expressionlist Comma expression .

    RParen          reduce using rule 24 (expressionlist -> expressionlist Comma expression .)
    Comma           reduce using rule 24 (expressionlist -> expressionlist Comma expression .)


state 136

    (113) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 113 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 113 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 113 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 113 (conditional -> logical_or Question expression Colon conditional .)
    RMidBrace       reduce using rule 113 (conditional -> logical_or Question expression Colon conditional .)


state 137

    (8) globaldeclaration -> type Identifier indexlist Assign LBrace set RBrace Semi .

    Int             reduce using rule 8 (globaldeclaration -> type Identifier indexlist Assign LBrace set RBrace Semi .)
    $end            reduce using rule 8 (globaldeclaration -> type Identifier indexlist Assign LBrace set RBrace Semi .)


state 138

    (11) set -> set Comma Integer .

    RBrace          reduce using rule 11 (set -> set Comma Integer .)
    Comma           reduce using rule 11 (set -> set Comma Integer .)


state 139

    (69) declaration -> type Identifier .
    (70) declaration -> type Identifier . Assign expression
    (71) declaration -> type Identifier . indexlist
    (72) declaration -> type Identifier . indexlist Assign LBrace set RBrace
    (73) indexlist -> . indexlist LMidBrace Integer RMidBrace
    (74) indexlist -> . LMidBrace Integer RMidBrace

    Semi            reduce using rule 69 (declaration -> type Identifier .)
    Assign          shift and go to state 151
    LMidBrace       shift and go to state 12

    indexlist                      shift and go to state 152

state 140

    (64) statement_matched -> LBrace block . RBrace
    (25) block -> block . block_item
    (27) block_item -> . statement
    (28) block_item -> . declaration Semi
    (29) statement -> . statement_matched
    (30) statement -> . statement_unmatched
    (69) declaration -> . type Identifier
    (70) declaration -> . type Identifier Assign expression
    (71) declaration -> . type Identifier indexlist
    (72) declaration -> . type Identifier indexlist Assign LBrace set RBrace
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (12) type -> . Int
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RBrace          shift and go to state 153
    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Int             shift and go to state 6
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    block_item                     shift and go to state 120
    statement                      shift and go to state 121
    declaration                    shift and go to state 122
    statement_matched              shift and go to state 123
    statement_unmatched            shift and go to state 124
    type                           shift and go to state 117
    expression                     shift and go to state 125
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 141

    (28) block_item -> declaration Semi .

    RBrace          reduce using rule 28 (block_item -> declaration Semi .)
    If              reduce using rule 28 (block_item -> declaration Semi .)
    While           reduce using rule 28 (block_item -> declaration Semi .)
    For             reduce using rule 28 (block_item -> declaration Semi .)
    Do              reduce using rule 28 (block_item -> declaration Semi .)
    Return          reduce using rule 28 (block_item -> declaration Semi .)
    LBrace          reduce using rule 28 (block_item -> declaration Semi .)
    Break           reduce using rule 28 (block_item -> declaration Semi .)
    Continue        reduce using rule 28 (block_item -> declaration Semi .)
    Int             reduce using rule 28 (block_item -> declaration Semi .)
    Identifier      reduce using rule 28 (block_item -> declaration Semi .)
    Integer         reduce using rule 28 (block_item -> declaration Semi .)
    LParen          reduce using rule 28 (block_item -> declaration Semi .)
    Minus           reduce using rule 28 (block_item -> declaration Semi .)
    BitNot          reduce using rule 28 (block_item -> declaration Semi .)
    Not             reduce using rule 28 (block_item -> declaration Semi .)
    Semi            reduce using rule 28 (block_item -> declaration Semi .)


state 142

    (31) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (32) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> If LParen . expression RParen statement
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 154
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 143

    (34) statement_matched -> While LParen . expression RParen statement_matched
    (35) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 155
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 144

    (36) statement_matched -> For LParen . expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> For LParen . declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> For LParen . Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> For LParen . expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> For LParen . declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> For LParen . expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> For LParen . declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> For LParen . expression Semi Semi RParen statement_matched
    (51) statement_matched -> For LParen . declaration Semi Semi RParen statement_matched
    (54) statement_matched -> For LParen . Semi expression Semi RParen statement_matched
    (56) statement_matched -> For LParen . Semi Semi expression RParen statement_matched
    (58) statement_matched -> For LParen . Semi Semi RParen statement_matched
    (38) statement_unmatched -> For LParen . expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> For LParen . declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> For LParen . Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> For LParen . expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> For LParen . declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> For LParen . expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> For LParen . declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> For LParen . expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> For LParen . declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> For LParen . Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> For LParen . Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> For LParen . Semi Semi RParen statement_unmatched
    (75) expression -> . assignment
    (69) declaration -> . type Identifier
    (70) declaration -> . type Identifier Assign expression
    (71) declaration -> . type Identifier indexlist
    (72) declaration -> . type Identifier indexlist Assign LBrace set RBrace
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (12) type -> . Int
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Semi            shift and go to state 157
    Int             shift and go to state 6
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 156
    declaration                    shift and go to state 158
    assignment                     shift and go to state 19
    type                           shift and go to state 117
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 145

    (60) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 159


state 146

    (61) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 160


state 147

    (62) statement_matched -> Return expression . Semi

    Semi            shift and go to state 161


state 148

    (63) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 63 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 63 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 63 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 63 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 63 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 63 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 63 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 63 (statement_matched -> opt_expression Semi .)


state 149

    (65) statement_matched -> Break Semi .

    RBrace          reduce using rule 65 (statement_matched -> Break Semi .)
    If              reduce using rule 65 (statement_matched -> Break Semi .)
    While           reduce using rule 65 (statement_matched -> Break Semi .)
    For             reduce using rule 65 (statement_matched -> Break Semi .)
    Do              reduce using rule 65 (statement_matched -> Break Semi .)
    Return          reduce using rule 65 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 65 (statement_matched -> Break Semi .)
    Break           reduce using rule 65 (statement_matched -> Break Semi .)
    Continue        reduce using rule 65 (statement_matched -> Break Semi .)
    Int             reduce using rule 65 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 65 (statement_matched -> Break Semi .)
    Integer         reduce using rule 65 (statement_matched -> Break Semi .)
    LParen          reduce using rule 65 (statement_matched -> Break Semi .)
    Minus           reduce using rule 65 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 65 (statement_matched -> Break Semi .)
    Not             reduce using rule 65 (statement_matched -> Break Semi .)
    Semi            reduce using rule 65 (statement_matched -> Break Semi .)
    Else            reduce using rule 65 (statement_matched -> Break Semi .)


state 150

    (66) statement_matched -> Continue Semi .

    RBrace          reduce using rule 66 (statement_matched -> Continue Semi .)
    If              reduce using rule 66 (statement_matched -> Continue Semi .)
    While           reduce using rule 66 (statement_matched -> Continue Semi .)
    For             reduce using rule 66 (statement_matched -> Continue Semi .)
    Do              reduce using rule 66 (statement_matched -> Continue Semi .)
    Return          reduce using rule 66 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 66 (statement_matched -> Continue Semi .)
    Break           reduce using rule 66 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 66 (statement_matched -> Continue Semi .)
    Int             reduce using rule 66 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 66 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 66 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 66 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 66 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 66 (statement_matched -> Continue Semi .)
    Not             reduce using rule 66 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 66 (statement_matched -> Continue Semi .)
    Else            reduce using rule 66 (statement_matched -> Continue Semi .)


state 151

    (70) declaration -> type Identifier Assign . expression
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 162
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 152

    (71) declaration -> type Identifier indexlist .
    (72) declaration -> type Identifier indexlist . Assign LBrace set RBrace
    (73) indexlist -> indexlist . LMidBrace Integer RMidBrace

    Semi            reduce using rule 71 (declaration -> type Identifier indexlist .)
    Assign          shift and go to state 163
    LMidBrace       shift and go to state 41


state 153

    (64) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 64 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 64 (statement_matched -> LBrace block RBrace .)


state 154

    (31) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (32) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 164


state 155

    (34) statement_matched -> While LParen expression . RParen statement_matched
    (35) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 165


state 156

    (36) statement_matched -> For LParen expression . Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> For LParen expression . Semi Semi expression RParen statement_matched
    (46) statement_matched -> For LParen expression . Semi expression Semi RParen statement_matched
    (50) statement_matched -> For LParen expression . Semi Semi RParen statement_matched
    (38) statement_unmatched -> For LParen expression . Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> For LParen expression . Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> For LParen expression . Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> For LParen expression . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 166


state 157

    (40) statement_matched -> For LParen Semi . expression Semi expression RParen statement_matched
    (54) statement_matched -> For LParen Semi . expression Semi RParen statement_matched
    (56) statement_matched -> For LParen Semi . Semi expression RParen statement_matched
    (58) statement_matched -> For LParen Semi . Semi RParen statement_matched
    (41) statement_unmatched -> For LParen Semi . expression Semi expression RParen statement_unmatched
    (55) statement_unmatched -> For LParen Semi . expression Semi RParen statement_unmatched
    (57) statement_unmatched -> For LParen Semi . Semi expression RParen statement_unmatched
    (59) statement_unmatched -> For LParen Semi . Semi RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Semi            shift and go to state 167
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 168
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 158

    (37) statement_matched -> For LParen declaration . Semi expression Semi expression RParen statement_matched
    (43) statement_matched -> For LParen declaration . Semi Semi expression RParen statement_matched
    (47) statement_matched -> For LParen declaration . Semi expression Semi RParen statement_matched
    (51) statement_matched -> For LParen declaration . Semi Semi RParen statement_matched
    (39) statement_unmatched -> For LParen declaration . Semi expression Semi expression RParen statement_unmatched
    (45) statement_unmatched -> For LParen declaration . Semi Semi expression RParen statement_unmatched
    (49) statement_unmatched -> For LParen declaration . Semi expression Semi RParen statement_unmatched
    (53) statement_unmatched -> For LParen declaration . Semi Semi RParen statement_unmatched

    Semi            shift and go to state 169


state 159

    (60) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 170


state 160

    (61) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 171


state 161

    (62) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 62 (statement_matched -> Return expression Semi .)
    If              reduce using rule 62 (statement_matched -> Return expression Semi .)
    While           reduce using rule 62 (statement_matched -> Return expression Semi .)
    For             reduce using rule 62 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 62 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 62 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 62 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 62 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 62 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 62 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 62 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 62 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 62 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 62 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 62 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 62 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 62 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 62 (statement_matched -> Return expression Semi .)


state 162

    (70) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 70 (declaration -> type Identifier Assign expression .)


state 163

    (72) declaration -> type Identifier indexlist Assign . LBrace set RBrace

    LBrace          shift and go to state 172


state 164

    (31) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (32) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (33) statement_unmatched -> If LParen expression RParen . statement
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (29) statement -> . statement_matched
    (30) statement -> . statement_unmatched
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 173
    statement_unmatched            shift and go to state 124
    statement                      shift and go to state 174
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 165

    (34) statement_matched -> While LParen expression RParen . statement_matched
    (35) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 175
    statement_unmatched            shift and go to state 176
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 166

    (36) statement_matched -> For LParen expression Semi . expression Semi expression RParen statement_matched
    (42) statement_matched -> For LParen expression Semi . Semi expression RParen statement_matched
    (46) statement_matched -> For LParen expression Semi . expression Semi RParen statement_matched
    (50) statement_matched -> For LParen expression Semi . Semi RParen statement_matched
    (38) statement_unmatched -> For LParen expression Semi . expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> For LParen expression Semi . Semi expression RParen statement_unmatched
    (48) statement_unmatched -> For LParen expression Semi . expression Semi RParen statement_unmatched
    (52) statement_unmatched -> For LParen expression Semi . Semi RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Semi            shift and go to state 178
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 177
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 167

    (56) statement_matched -> For LParen Semi Semi . expression RParen statement_matched
    (58) statement_matched -> For LParen Semi Semi . RParen statement_matched
    (57) statement_unmatched -> For LParen Semi Semi . expression RParen statement_unmatched
    (59) statement_unmatched -> For LParen Semi Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 180
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 179
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 168

    (40) statement_matched -> For LParen Semi expression . Semi expression RParen statement_matched
    (54) statement_matched -> For LParen Semi expression . Semi RParen statement_matched
    (41) statement_unmatched -> For LParen Semi expression . Semi expression RParen statement_unmatched
    (55) statement_unmatched -> For LParen Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 181


state 169

    (37) statement_matched -> For LParen declaration Semi . expression Semi expression RParen statement_matched
    (43) statement_matched -> For LParen declaration Semi . Semi expression RParen statement_matched
    (47) statement_matched -> For LParen declaration Semi . expression Semi RParen statement_matched
    (51) statement_matched -> For LParen declaration Semi . Semi RParen statement_matched
    (39) statement_unmatched -> For LParen declaration Semi . expression Semi expression RParen statement_unmatched
    (45) statement_unmatched -> For LParen declaration Semi . Semi expression RParen statement_unmatched
    (49) statement_unmatched -> For LParen declaration Semi . expression Semi RParen statement_unmatched
    (53) statement_unmatched -> For LParen declaration Semi . Semi RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Semi            shift and go to state 182
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 183
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 170

    (60) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 184
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 171

    (61) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 185
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 172

    (72) declaration -> type Identifier indexlist Assign LBrace . set RBrace
    (9) set -> . empty
    (10) set -> . Integer
    (11) set -> . set Comma Integer
    (1) empty -> .

    Integer         shift and go to state 105
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    set                            shift and go to state 186
    empty                          shift and go to state 104

state 173

    (31) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (32) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (29) statement -> statement_matched .

    Else            shift and go to state 187
    RBrace          reduce using rule 29 (statement -> statement_matched .)
    If              reduce using rule 29 (statement -> statement_matched .)
    While           reduce using rule 29 (statement -> statement_matched .)
    For             reduce using rule 29 (statement -> statement_matched .)
    Do              reduce using rule 29 (statement -> statement_matched .)
    Return          reduce using rule 29 (statement -> statement_matched .)
    LBrace          reduce using rule 29 (statement -> statement_matched .)
    Break           reduce using rule 29 (statement -> statement_matched .)
    Continue        reduce using rule 29 (statement -> statement_matched .)
    Int             reduce using rule 29 (statement -> statement_matched .)
    Identifier      reduce using rule 29 (statement -> statement_matched .)
    Integer         reduce using rule 29 (statement -> statement_matched .)
    LParen          reduce using rule 29 (statement -> statement_matched .)
    Minus           reduce using rule 29 (statement -> statement_matched .)
    BitNot          reduce using rule 29 (statement -> statement_matched .)
    Not             reduce using rule 29 (statement -> statement_matched .)
    Semi            reduce using rule 29 (statement -> statement_matched .)


state 174

    (33) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 33 (statement_unmatched -> If LParen expression RParen statement .)


state 175

    (34) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 34 (statement_matched -> While LParen expression RParen statement_matched .)


state 176

    (35) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 35 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 177

    (36) statement_matched -> For LParen expression Semi expression . Semi expression RParen statement_matched
    (46) statement_matched -> For LParen expression Semi expression . Semi RParen statement_matched
    (38) statement_unmatched -> For LParen expression Semi expression . Semi expression RParen statement_unmatched
    (48) statement_unmatched -> For LParen expression Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 188


state 178

    (42) statement_matched -> For LParen expression Semi Semi . expression RParen statement_matched
    (50) statement_matched -> For LParen expression Semi Semi . RParen statement_matched
    (44) statement_unmatched -> For LParen expression Semi Semi . expression RParen statement_unmatched
    (52) statement_unmatched -> For LParen expression Semi Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 190
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 189
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 179

    (56) statement_matched -> For LParen Semi Semi expression . RParen statement_matched
    (57) statement_unmatched -> For LParen Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 191


state 180

    (58) statement_matched -> For LParen Semi Semi RParen . statement_matched
    (59) statement_unmatched -> For LParen Semi Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    statement_matched              shift and go to state 192
    statement_unmatched            shift and go to state 193
    expression                     shift and go to state 125
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 181

    (40) statement_matched -> For LParen Semi expression Semi . expression RParen statement_matched
    (54) statement_matched -> For LParen Semi expression Semi . RParen statement_matched
    (41) statement_unmatched -> For LParen Semi expression Semi . expression RParen statement_unmatched
    (55) statement_unmatched -> For LParen Semi expression Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 195
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 194
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 182

    (43) statement_matched -> For LParen declaration Semi Semi . expression RParen statement_matched
    (51) statement_matched -> For LParen declaration Semi Semi . RParen statement_matched
    (45) statement_unmatched -> For LParen declaration Semi Semi . expression RParen statement_unmatched
    (53) statement_unmatched -> For LParen declaration Semi Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 197
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 196
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 183

    (37) statement_matched -> For LParen declaration Semi expression . Semi expression RParen statement_matched
    (47) statement_matched -> For LParen declaration Semi expression . Semi RParen statement_matched
    (39) statement_unmatched -> For LParen declaration Semi expression . Semi expression RParen statement_unmatched
    (49) statement_unmatched -> For LParen declaration Semi expression . Semi RParen statement_unmatched

    Semi            shift and go to state 198


state 184

    (60) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 199


state 185

    (61) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 200


state 186

    (72) declaration -> type Identifier indexlist Assign LBrace set . RBrace
    (11) set -> set . Comma Integer

    RBrace          shift and go to state 201
    Comma           shift and go to state 115


state 187

    (31) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (32) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 202
    statement_unmatched            shift and go to state 203
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 188

    (36) statement_matched -> For LParen expression Semi expression Semi . expression RParen statement_matched
    (46) statement_matched -> For LParen expression Semi expression Semi . RParen statement_matched
    (38) statement_unmatched -> For LParen expression Semi expression Semi . expression RParen statement_unmatched
    (48) statement_unmatched -> For LParen expression Semi expression Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 205
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 204
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 189

    (42) statement_matched -> For LParen expression Semi Semi expression . RParen statement_matched
    (44) statement_unmatched -> For LParen expression Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 206


state 190

    (50) statement_matched -> For LParen expression Semi Semi RParen . statement_matched
    (52) statement_unmatched -> For LParen expression Semi Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 207
    statement_unmatched            shift and go to state 208
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 191

    (56) statement_matched -> For LParen Semi Semi expression RParen . statement_matched
    (57) statement_unmatched -> For LParen Semi Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 209
    statement_unmatched            shift and go to state 210
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 192

    (58) statement_matched -> For LParen Semi Semi RParen statement_matched .

    RBrace          reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    If              reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    While           reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    For             reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Do              reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Return          reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Break           reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Continue        reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Int             reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Integer         reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    LParen          reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Minus           reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Not             reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Semi            reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)
    Else            reduce using rule 58 (statement_matched -> For LParen Semi Semi RParen statement_matched .)


state 193

    (59) statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    If              reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    While           reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    For             reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 59 (statement_unmatched -> For LParen Semi Semi RParen statement_unmatched .)


state 194

    (40) statement_matched -> For LParen Semi expression Semi expression . RParen statement_matched
    (41) statement_unmatched -> For LParen Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 211


state 195

    (54) statement_matched -> For LParen Semi expression Semi RParen . statement_matched
    (55) statement_unmatched -> For LParen Semi expression Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 212
    statement_unmatched            shift and go to state 213
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 196

    (43) statement_matched -> For LParen declaration Semi Semi expression . RParen statement_matched
    (45) statement_unmatched -> For LParen declaration Semi Semi expression . RParen statement_unmatched

    RParen          shift and go to state 214


state 197

    (51) statement_matched -> For LParen declaration Semi Semi RParen . statement_matched
    (53) statement_unmatched -> For LParen declaration Semi Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    statement_matched              shift and go to state 215
    statement_unmatched            shift and go to state 216
    expression                     shift and go to state 125
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 198

    (37) statement_matched -> For LParen declaration Semi expression Semi . expression RParen statement_matched
    (47) statement_matched -> For LParen declaration Semi expression Semi . RParen statement_matched
    (39) statement_unmatched -> For LParen declaration Semi expression Semi . expression RParen statement_unmatched
    (49) statement_unmatched -> For LParen declaration Semi expression Semi . RParen statement_unmatched
    (75) expression -> . assignment
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    RParen          shift and go to state 218
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 217
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 199

    (60) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 219


state 200

    (61) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 220


state 201

    (72) declaration -> type Identifier indexlist Assign LBrace set RBrace .

    Semi            reduce using rule 72 (declaration -> type Identifier indexlist Assign LBrace set RBrace .)


state 202

    (31) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 31 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 203

    (32) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 32 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 204

    (36) statement_matched -> For LParen expression Semi expression Semi expression . RParen statement_matched
    (38) statement_unmatched -> For LParen expression Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 221


state 205

    (46) statement_matched -> For LParen expression Semi expression Semi RParen . statement_matched
    (48) statement_unmatched -> For LParen expression Semi expression Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 222
    statement_unmatched            shift and go to state 223
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 206

    (42) statement_matched -> For LParen expression Semi Semi expression RParen . statement_matched
    (44) statement_unmatched -> For LParen expression Semi Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 224
    statement_unmatched            shift and go to state 225
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 207

    (50) statement_matched -> For LParen expression Semi Semi RParen statement_matched .

    RBrace          reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    If              reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    While           reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    For             reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Do              reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Return          reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Break           reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Continue        reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Int             reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Integer         reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    LParen          reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Minus           reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Not             reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Semi            reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)
    Else            reduce using rule 50 (statement_matched -> For LParen expression Semi Semi RParen statement_matched .)


state 208

    (52) statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    If              reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    While           reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    For             reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 52 (statement_unmatched -> For LParen expression Semi Semi RParen statement_unmatched .)


state 209

    (56) statement_matched -> For LParen Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    If              reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    While           reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    For             reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 56 (statement_matched -> For LParen Semi Semi expression RParen statement_matched .)


state 210

    (57) statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 57 (statement_unmatched -> For LParen Semi Semi expression RParen statement_unmatched .)


state 211

    (40) statement_matched -> For LParen Semi expression Semi expression RParen . statement_matched
    (41) statement_unmatched -> For LParen Semi expression Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 226
    statement_unmatched            shift and go to state 227
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 212

    (54) statement_matched -> For LParen Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    If              reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    While           reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    For             reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 54 (statement_matched -> For LParen Semi expression Semi RParen statement_matched .)


state 213

    (55) statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 55 (statement_unmatched -> For LParen Semi expression Semi RParen statement_unmatched .)


state 214

    (43) statement_matched -> For LParen declaration Semi Semi expression RParen . statement_matched
    (45) statement_unmatched -> For LParen declaration Semi Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 228
    statement_unmatched            shift and go to state 229
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 215

    (51) statement_matched -> For LParen declaration Semi Semi RParen statement_matched .

    RBrace          reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    If              reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    While           reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    For             reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Do              reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Return          reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LBrace          reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Break           reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Continue        reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Int             reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Identifier      reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Integer         reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    LParen          reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Minus           reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    BitNot          reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Not             reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Semi            reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)
    Else            reduce using rule 51 (statement_matched -> For LParen declaration Semi Semi RParen statement_matched .)


state 216

    (53) statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .

    RBrace          reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    If              reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    While           reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    For             reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Do              reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Return          reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LBrace          reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Break           reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Continue        reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Int             reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Identifier      reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Integer         reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    LParen          reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Minus           reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    BitNot          reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Not             reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)
    Semi            reduce using rule 53 (statement_unmatched -> For LParen declaration Semi Semi RParen statement_unmatched .)


state 217

    (37) statement_matched -> For LParen declaration Semi expression Semi expression . RParen statement_matched
    (39) statement_unmatched -> For LParen declaration Semi expression Semi expression . RParen statement_unmatched

    RParen          shift and go to state 230


state 218

    (47) statement_matched -> For LParen declaration Semi expression Semi RParen . statement_matched
    (49) statement_unmatched -> For LParen declaration Semi expression Semi RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 231
    statement_unmatched            shift and go to state 232
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 219

    (60) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 60 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 220

    (61) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 61 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 221

    (36) statement_matched -> For LParen expression Semi expression Semi expression RParen . statement_matched
    (38) statement_unmatched -> For LParen expression Semi expression Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 233
    statement_unmatched            shift and go to state 234
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 222

    (46) statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    If              reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    While           reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    For             reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 46 (statement_matched -> For LParen expression Semi expression Semi RParen statement_matched .)


state 223

    (48) statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 48 (statement_unmatched -> For LParen expression Semi expression Semi RParen statement_unmatched .)


state 224

    (42) statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    If              reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    While           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    For             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 42 (statement_matched -> For LParen expression Semi Semi expression RParen statement_matched .)


state 225

    (44) statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 44 (statement_unmatched -> For LParen expression Semi Semi expression RParen statement_unmatched .)


state 226

    (40) statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 40 (statement_matched -> For LParen Semi expression Semi expression RParen statement_matched .)


state 227

    (41) statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 41 (statement_unmatched -> For LParen Semi expression Semi expression RParen statement_unmatched .)


state 228

    (43) statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .

    RBrace          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    If              reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    While           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    For             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Do              reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Return          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LBrace          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Break           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Continue        reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Int             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Identifier      reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Integer         reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    LParen          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Minus           reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    BitNot          reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Not             reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Semi            reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)
    Else            reduce using rule 43 (statement_matched -> For LParen declaration Semi Semi expression RParen statement_matched .)


state 229

    (45) statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    If              reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    While           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    For             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Do              reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Return          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Break           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Int             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Not             reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 45 (statement_unmatched -> For LParen declaration Semi Semi expression RParen statement_unmatched .)


state 230

    (37) statement_matched -> For LParen declaration Semi expression Semi expression RParen . statement_matched
    (39) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen . statement_unmatched
    (31) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (34) statement_matched -> . While LParen expression RParen statement_matched
    (36) statement_matched -> . For LParen expression Semi expression Semi expression RParen statement_matched
    (37) statement_matched -> . For LParen declaration Semi expression Semi expression RParen statement_matched
    (40) statement_matched -> . For LParen Semi expression Semi expression RParen statement_matched
    (42) statement_matched -> . For LParen expression Semi Semi expression RParen statement_matched
    (43) statement_matched -> . For LParen declaration Semi Semi expression RParen statement_matched
    (46) statement_matched -> . For LParen expression Semi expression Semi RParen statement_matched
    (47) statement_matched -> . For LParen declaration Semi expression Semi RParen statement_matched
    (50) statement_matched -> . For LParen expression Semi Semi RParen statement_matched
    (51) statement_matched -> . For LParen declaration Semi Semi RParen statement_matched
    (54) statement_matched -> . For LParen Semi expression Semi RParen statement_matched
    (56) statement_matched -> . For LParen Semi Semi expression RParen statement_matched
    (58) statement_matched -> . For LParen Semi Semi RParen statement_matched
    (60) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (62) statement_matched -> . Return expression Semi
    (63) statement_matched -> . opt_expression Semi
    (64) statement_matched -> . LBrace block RBrace
    (65) statement_matched -> . Break Semi
    (66) statement_matched -> . Continue Semi
    (32) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (33) statement_unmatched -> . If LParen expression RParen statement
    (35) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (38) statement_unmatched -> . For LParen expression Semi expression Semi expression RParen statement_unmatched
    (39) statement_unmatched -> . For LParen declaration Semi expression Semi expression RParen statement_unmatched
    (41) statement_unmatched -> . For LParen Semi expression Semi expression RParen statement_unmatched
    (44) statement_unmatched -> . For LParen expression Semi Semi expression RParen statement_unmatched
    (45) statement_unmatched -> . For LParen declaration Semi Semi expression RParen statement_unmatched
    (48) statement_unmatched -> . For LParen expression Semi expression Semi RParen statement_unmatched
    (49) statement_unmatched -> . For LParen declaration Semi expression Semi RParen statement_unmatched
    (52) statement_unmatched -> . For LParen expression Semi Semi RParen statement_unmatched
    (53) statement_unmatched -> . For LParen declaration Semi Semi RParen statement_unmatched
    (55) statement_unmatched -> . For LParen Semi expression Semi RParen statement_unmatched
    (57) statement_unmatched -> . For LParen Semi Semi expression RParen statement_unmatched
    (59) statement_unmatched -> . For LParen Semi Semi RParen statement_unmatched
    (61) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (67) opt_expression -> . expression
    (68) opt_expression -> . empty
    (75) expression -> . assignment
    (1) empty -> .
    (76) assignment -> . conditional
    (96) assignment -> . postfix Assign expression
    (77) conditional -> . logical_or
    (113) conditional -> . logical_or Question expression Colon conditional
    (88) postfix -> . primary
    (89) postfix -> . Identifier LParen expressionlist RParen
    (90) postfix -> . postfix_array LMidBrace expression RMidBrace
    (78) logical_or -> . logical_and
    (97) logical_or -> . logical_or Or logical_and
    (114) primary -> . Integer
    (115) primary -> . Identifier
    (116) primary -> . LParen expression RParen
    (91) postfix_array -> . postfix_array LMidBrace expression RMidBrace
    (92) postfix_array -> . primary
    (79) logical_and -> . bit_or
    (98) logical_and -> . logical_and And bit_or
    (80) bit_or -> . xor
    (99) bit_or -> . bit_or BitOr xor
    (81) xor -> . bit_and
    (100) xor -> . xor Xor bit_and
    (82) bit_and -> . equality
    (101) bit_and -> . bit_and BitAnd equality
    (83) equality -> . relational
    (102) equality -> . equality NotEqual relational
    (103) equality -> . equality Equal relational
    (84) relational -> . additive
    (104) relational -> . relational Less additive
    (105) relational -> . relational Greater additive
    (106) relational -> . relational LessEqual additive
    (107) relational -> . relational GreaterEqual additive
    (85) additive -> . multiplicative
    (108) additive -> . additive Plus multiplicative
    (109) additive -> . additive Minus multiplicative
    (86) multiplicative -> . unary
    (110) multiplicative -> . multiplicative Mul unary
    (111) multiplicative -> . multiplicative Div unary
    (112) multiplicative -> . multiplicative Mod unary
    (87) unary -> . postfix
    (93) unary -> . Minus unary
    (94) unary -> . BitNot unary
    (95) unary -> . Not unary

    If              shift and go to state 126
    While           shift and go to state 127
    For             shift and go to state 128
    Do              shift and go to state 129
    Return          shift and go to state 130
    LBrace          shift and go to state 118
    Break           shift and go to state 132
    Continue        shift and go to state 133
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Integer         shift and go to state 27
    LParen          shift and go to state 24
    Minus           shift and go to state 35
    BitNot          shift and go to state 37
    Not             shift and go to state 38

    expression                     shift and go to state 125
    statement_matched              shift and go to state 235
    statement_unmatched            shift and go to state 236
    opt_expression                 shift and go to state 131
    empty                          shift and go to state 134
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    postfix                        shift and go to state 21
    logical_or                     shift and go to state 22
    primary                        shift and go to state 23
    postfix_array                  shift and go to state 25
    logical_and                    shift and go to state 26
    bit_or                         shift and go to state 28
    xor                            shift and go to state 29
    bit_and                        shift and go to state 30
    equality                       shift and go to state 31
    relational                     shift and go to state 32
    additive                       shift and go to state 33
    multiplicative                 shift and go to state 34
    unary                          shift and go to state 36

state 231

    (47) statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .

    RBrace          reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    If              reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    While           reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    For             reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Do              reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Return          reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LBrace          reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Break           reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Continue        reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Int             reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Identifier      reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Integer         reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    LParen          reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Minus           reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    BitNot          reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Not             reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Semi            reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)
    Else            reduce using rule 47 (statement_matched -> For LParen declaration Semi expression Semi RParen statement_matched .)


state 232

    (49) statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .

    RBrace          reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    If              reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    While           reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    For             reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Do              reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Return          reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LBrace          reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Break           reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Continue        reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Int             reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Identifier      reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Integer         reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    LParen          reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Minus           reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    BitNot          reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Not             reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)
    Semi            reduce using rule 49 (statement_unmatched -> For LParen declaration Semi expression Semi RParen statement_unmatched .)


state 233

    (36) statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 36 (statement_matched -> For LParen expression Semi expression Semi expression RParen statement_matched .)


state 234

    (38) statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 38 (statement_unmatched -> For LParen expression Semi expression Semi expression RParen statement_unmatched .)


state 235

    (37) statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .

    RBrace          reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    If              reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    While           reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    For             reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Do              reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Return          reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LBrace          reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Break           reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Continue        reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Int             reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Identifier      reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Integer         reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    LParen          reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Minus           reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    BitNot          reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Not             reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Semi            reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)
    Else            reduce using rule 37 (statement_matched -> For LParen declaration Semi expression Semi expression RParen statement_matched .)


state 236

    (39) statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .

    RBrace          reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    If              reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    While           reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    For             reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Do              reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Return          reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LBrace          reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Break           reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Continue        reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Int             reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Identifier      reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Integer         reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    LParen          reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Minus           reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    BitNot          reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Not             reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)
    Semi            reduce using rule 39 (statement_unmatched -> For LParen declaration Semi expression Semi expression RParen statement_unmatched .)

